<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🤠 GUNSLINGER'S BREAKOUT: WILD WEST SHOWDOWN 🔫</title>
    <link rel="manifest" href="data:application/manifest+json;base64,eyJuYW1lIjoiQ3liZXIgQnJlYWtvdXQ6IE5lb24gQW5uaWhpbGF0aW9uIiwic2hvcnRfbmFtZSI6IkN5YmVyIEJyZWFrb3V0IiwiZGVzY3JpcHRpb24iOiJBbiBhZHZhbmNlZCBicmVha291dCBnYW1lIHdpdGggY3liZXJwdW5rIGFlc3RoZXRpY3MgYW5kIGFkdmFuY2VkIGdhbWVwbGF5IG1lY2hhbmljcyIsInN0YXJ0X3VybCI6Ii4vIiwiZGlzcGxheSI6InN0YW5kYWxvbmUiLCJiYWNrZ3JvdW5kX2NvbG9yIjoiIzAwMDAwMCIsInRoZW1lX2NvbG9yIjoiIzAwZmZmZiIsImljb25zIjpbeyJzcmMiOiJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNBQUFBQWdDQVlBQUFCemVucjBBQUFBQkdkQlRVRUFBTEdQQy94aEJRQUFBQ0JqU0ZKTkFBQjZKZ0FBZ0lRQUFQb0FBQUNBK2dBQUFJZ0tBQUE2WitHVEFBQUFGSkVCVmdsV1dPZE5RRkdxamcxZzV5WFhKOGhIOSs2VzNsdjMzaFRKYkdvZz09IiwidHlwZSI6ImltYWdlL3BuZyIsInNpemVzIjoiMzJ4MzIifSx7InNyYyI6ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBR0FBQUFCZ0NBWUFBQUJ6ZW5yMEFBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFDQmpTRkpOQUFCNkpnQUFnSVFBQVBvQUFBQ0Erg0FBQUlnS0FBQTZaK0dUQUFBQUZKRUJWZ2xXV09kTlFGR3FqZzFnNXlYWEo4aEg5KzZXM2x2MzNoVEpiR29nPT0iLCJ0eXBlIjoiaW1hZ2UvcG5nIiwic2l6ZXMiOiI5Nng5NiJ9LHsic3JjIjoiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFRQUFBQUVBQ0FZQUFBQW16ZW5yMEFBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFDQmpTRkpOQUFCNkpnQUFnSVFBQVBvQUFBQ0Erg0FBQUlnS0FBQTZaK0dUQUFBQUZKRUJWZ2xXV09kTlFGR3FqZzFnNXlYWEo4aEg5KzZXM2x2MzNoVEpiR29nPT0iLCJ0eXBlIjoiaW1hZ2UvcG5nIiwic2l6ZXMiOiIyNTZ4MjU2In1dfQ==">
    <meta name="theme-color" content="#d4af37">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Gunslinger's Breakout">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rye:wght@400&family=Creepster:wght@400&family=Butcherman:wght@400&family=New+Rocker:wght@400&family=Nosifer:wght@400&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            background: 
                radial-gradient(ellipse at center, rgba(101, 67, 33, 0.8), rgba(62, 39, 35, 0.9)),
                repeating-linear-gradient(
                    90deg,
                    #8b4513 0px,
                    #a0522d 2px,
                    #8b4513 4px,
                    #654321 6px,
                    #8b4513 8px
                ),
                repeating-linear-gradient(
                    0deg,
                    transparent 0px,
                    rgba(139, 69, 19, 0.1) 1px,
                    transparent 2px
                );
            font-family: 'Rye', 'New Rocker', 'Butcherman', serif;
            color: #deb887;
            overflow: hidden;
        }

        .game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(ellipse at center, #8b7355 0%, #6b5b47 30%, #4a3728 60%, #2d1810 100%),
                repeating-linear-gradient(
                    45deg,
                    transparent 0px,
                    rgba(139, 115, 85, 0.1) 1px,
                    transparent 2px,
                    rgba(107, 91, 71, 0.1) 3px,
                    transparent 4px
                );
            display: block;
            filter: contrast(1.2) saturate(1.1) sepia(0.3);
            image-rendering: pixelated;
            border: 4px solid #654321;
            box-shadow: inset 0 0 50px rgba(139, 69, 19, 0.3);
        }

        .level-info {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: 
                linear-gradient(145deg, #f4e4bc, #e6d7b8),
                repeating-linear-gradient(90deg, transparent 0px, rgba(139, 69, 19, 0.05) 1px, transparent 2px);
            padding: 12px 25px;
            border-radius: 8px;
            border: 4px solid #8b4513;
            font-size: 16px;
            font-weight: bold;
            color: #5d4037;
            text-shadow: 1px 1px 0px rgba(222, 184, 135, 0.8);
            box-shadow: 
                0 0 0 2px #654321,
                0 6px 12px rgba(139, 69, 19, 0.4),
                inset 0 2px 4px rgba(222, 184, 135, 0.8);
            font-family: 'Butcherman', serif;
        }

        .combo-display {
            position: absolute;
            top: 80px;
            right: 20px;
            background: linear-gradient(135deg, rgba(218, 165, 32, 0.9), rgba(184, 134, 11, 0.9));
            padding: 10px 15px;
            border-radius: 10px;
            border: 3px solid #8b4513;
            font-size: 14px;
            font-weight: bold;
            color: #2f1b14;
            text-shadow: 1px 1px 2px #d4af37;
            transform: scale(1);
            transition: transform 0.3s ease;
            box-shadow: 0 0 10px rgba(139, 69, 19, 0.6);
        }

        .combo-display.active {
            transform: scale(1.2);
            animation: comboGlow 0.5s ease-in-out;
        }

        @keyframes comboGlow {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.8); }
            50% { box-shadow: 0 0 30px rgba(255, 215, 0, 1); }
        }

        .powerup-display {
            position: absolute;
            bottom: 100px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .powerup-item {
            background: linear-gradient(135deg, rgba(0, 255, 127, 0.9), rgba(0, 128, 0, 0.9));
            padding: 8px 12px;
            border-radius: 10px;
            font-size: 12px;
            color: #fff;
            animation: powerupPulse 2s infinite;
        }

        @keyframes powerupPulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; transform: scale(1.05); }
        }

        .game-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
            pointer-events: none;
        }

        .score, .lives {
            background: linear-gradient(135deg, rgba(0, 20, 40, 0.95), rgba(0, 10, 30, 0.95));
            padding: 15px 25px;
            border-radius: 12px;
            font-size: 20px;
            font-weight: bold;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }

        .score {
            color: #daa520;
            text-shadow: 0 0 10px #daa520;
        }

        .lives {
            color: #ff6600;
            text-shadow: 0 0 10px #ff6600;
        }

        .game-over, .start-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: 
                linear-gradient(45deg, 
                    #f4e4bc 0%, 
                    #e6d7b8 25%, 
                    #d4c5a9 50%, 
                    #c8b99c 75%, 
                    #b8a082 100%
                ),
                repeating-linear-gradient(
                    0deg,
                    transparent 0px,
                    rgba(139, 69, 19, 0.05) 1px,
                    transparent 2px,
                    rgba(139, 69, 19, 0.05) 3px,
                    transparent 4px
                ),
                repeating-linear-gradient(
                    90deg,
                    transparent 0px,
                    rgba(101, 67, 33, 0.03) 1px,
                    transparent 2px
                );
            padding: 50px 60px;
            border-radius: 8px;
            text-align: center;
            z-index: 20;
            border: 8px solid #8b4513;
            border-image: linear-gradient(45deg, #8b4513, #a0522d, #8b4513, #654321) 1;
            box-shadow: 
                0 0 0 4px #654321,
                0 0 0 8px #8b4513,
                0 30px 60px rgba(0, 0, 0, 0.4),
                inset 0 0 30px rgba(139, 69, 19, 0.1),
                inset 0 0 60px rgba(222, 184, 135, 0.1);
            min-width: 500px;
            max-width: 600px;
            position: relative;
        }
        
        .start-screen::before {
            content: '';
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            background: 
                repeating-conic-gradient(
                    from 0deg at 50% 50%,
                    #8b4513 0deg,
                    #a0522d 90deg,
                    #8b4513 180deg,
                    #654321 270deg
                );
            z-index: -1;
            border-radius: 12px;
        }
        
        .start-screen::after {
            content: '★ ★ ★ ★ ★';
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            color: #8b4513;
            font-size: 20px;
            letter-spacing: 8px;
        }

        .start-screen h1 {
            color: #8b4513;
            font-size: 48px;
            margin-bottom: 20px;
            margin-top: 30px;
            text-shadow: 
                2px 2px 0px #654321,
                4px 4px 0px #3e2723,
                6px 6px 10px rgba(0, 0, 0, 0.3);
            font-weight: 900;
            letter-spacing: 2px;
            font-family: 'Butcherman', 'Rye', serif;
            text-transform: uppercase;
            line-height: 1.1;
            position: relative;
        }
        
        .start-screen h1::before {
            content: 'WANTED';
            position: absolute;
            top: -35px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            color: #8b4513;
            font-family: 'New Rocker', serif;
            border: 3px solid #8b4513;
            padding: 5px 20px;
            background: rgba(222, 184, 135, 0.8);
            border-radius: 5px;
        }
        
        .start-screen h1 span {
            display: block;
            font-size: 0.6em;
            color: #a0522d !important;
            margin-top: 5px;
            font-family: 'Rye', serif;
            letter-spacing: 3px;
        }
        
        @keyframes westernGlow {
            from { 
                text-shadow: 2px 2px 4px #8b4513, 4px 4px 8px rgba(139, 69, 19, 0.5);
                transform: scale(1);
            }
            to { 
                text-shadow: 2px 2px 6px #8b4513, 4px 4px 12px rgba(139, 69, 19, 0.7), 0 0 15px rgba(218, 165, 32, 0.3);
                transform: scale(1.02);
            }
        }

        .start-screen p, .game-over p {
            font-size: 18px;
            margin: 15px 0;
            color: #5d4037;
            line-height: 1.5;
            text-shadow: 1px 1px 0px rgba(222, 184, 135, 0.8);
            font-family: 'Rye', serif;
            font-weight: bold;
        }

        .game-over h2 {
            color: #dc143c;
            font-size: 42px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px #8b4513, 0 0 15px rgba(220, 20, 60, 0.5);
            font-weight: 900;
        }

        .game-over h2.win {
            color: #daa520;
            text-shadow: 2px 2px 4px #8b4513, 0 0 15px rgba(218, 165, 32, 0.7);
        }

        .hidden {
            display: none;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 14px;
            color: #8b4513;
            background: 
                linear-gradient(145deg, #f4e4bc, #e6d7b8),
                repeating-linear-gradient(90deg, transparent 0px, rgba(139, 69, 19, 0.05) 1px, transparent 2px);
            padding: 15px 30px;
            border-radius: 8px;
            border: 3px solid #8b4513;
            box-shadow: 
                0 0 0 1px #654321,
                0 8px 16px rgba(139, 69, 19, 0.3),
                inset 0 2px 4px rgba(222, 184, 135, 0.8);
            font-family: 'Rye', serif;
            font-weight: bold;
            text-shadow: 1px 1px 0px rgba(222, 184, 135, 0.8);
        }

        .pulse {
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; transform: scale(1.05); }
        }

        .glow {
            animation: glow 3s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 10px currentColor; }
            to { text-shadow: 0 0 20px currentColor, 0 0 30px currentColor; }
        }
        
        .lightning {
            animation: lightning 0.1s linear infinite;
        }
        
        @keyframes lightning {
            0%, 90%, 100% { opacity: 1; }
            5%, 85% { opacity: 0.1; }
        }

        .chromatic-aberration {
            position: relative;
        }

        .chromatic-aberration::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: inherit;
            mix-blend-mode: screen;
            transform: translate(2px, 0);
            filter: hue-rotate(90deg);
            opacity: 0.3;
            pointer-events: none;
        }

        .chromatic-aberration::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: inherit;
            mix-blend-mode: screen;
            transform: translate(-2px, 0);
            filter: hue-rotate(270deg);
            opacity: 0.3;
            pointer-events: none;
        }

        @keyframes dataGlitch {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }

        .glitch-effect {
            animation: dataGlitch 0.3s infinite;
        }

        @keyframes neonFlicker {
            0%, 100% { 
                filter: brightness(1) drop-shadow(0 0 5px currentColor);
                opacity: 1;
            }
            2% { 
                filter: brightness(0.8) drop-shadow(0 0 3px currentColor);
                opacity: 0.8;
            }
            4% { 
                filter: brightness(1.2) drop-shadow(0 0 8px currentColor);
                opacity: 1;
            }
            95% {
                filter: brightness(0.9) drop-shadow(0 0 4px currentColor);
                opacity: 0.9;
            }
        }

        .neon-flicker {
            animation: neonFlicker 0.15s infinite;
        }
        
        @keyframes achievementSlide {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes achievementSlideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }
        
        @keyframes achievementGlow {
            from { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8); }
            to { box-shadow: 0 0 30px rgba(255, 215, 0, 1), 0 0 40px rgba(255, 140, 0, 0.6); }
        }
        
        @keyframes notificationPulse {
            from { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        
        .neon-border {
            border: 2px solid #cd853f;
            box-shadow: 0 0 10px #cd853f, inset 0 0 10px rgba(205, 133, 63, 0.1);
        }
        .scan-lines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 255, 255, 0.03) 2px,
                rgba(0, 255, 255, 0.03) 4px
            );
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="scan-lines"></div>
    <div class="game-container">
        <div class="start-screen" id="startScreen">
            <h1 class="glow">GUNSLINGER'S BREAKOUT<br><span>WILD WEST SHOWDOWN</span></h1>
            <div style="margin: 20px 0;">
                <label for="playerName" style="color: #8b4513; font-size: 20px; display: block; margin-bottom: 15px; text-shadow: 1px 1px 0px rgba(222, 184, 135, 0.8); font-family: 'Rye', serif; font-weight: bold;">~ NAME OF THE DESPERADO ~</label>
                <input type="text" id="playerName" maxlength="15" placeholder="OUTLAW" 
                       style="background: 
                           linear-gradient(145deg, #f4e4bc, #e6d7b8),
                           repeating-linear-gradient(90deg, transparent 0px, rgba(139, 69, 19, 0.05) 1px, transparent 2px);
                       border: 4px solid #8b4513; 
                       color: #3e2723; 
                       padding: 15px; 
                       border-radius: 6px; 
                       font-family: 'Butcherman', serif; 
                       text-align: center; 
                       font-size: 18px; 
                       text-transform: uppercase; 
                       font-weight: bold;
                       box-shadow: 
                           0 0 0 2px #654321,
                           0 6px 12px rgba(139, 69, 19, 0.4),
                           inset 0 2px 4px rgba(222, 184, 135, 0.8),
                           inset 0 -2px 4px rgba(139, 69, 19, 0.2);">
            </div>
            <div style="border: 2px solid #8b4513; padding: 15px; margin: 20px 0; background: rgba(222, 184, 135, 0.3); border-radius: 5px;">
                <p style="color: #8b4513; font-size: 16px; margin: 8px 0; font-family: 'Rye', serif;">★ REWARD: $1,000,000 DEAD OR ALIVE ★</p>
                <p style="color: #5d4037; font-size: 14px; margin: 8px 0;">Last seen terrorizing the frontier towns</p>
                <p style="color: #5d4037; font-size: 14px; margin: 8px 0;">Armed and extremely dangerous</p>
            </div>
            <p style="color: #8b4513; font-size: 16px; margin: 15px 0; font-family: 'New Rocker', serif;">→ Use WASD or ARROW KEYS to aim ←</p>
            <p class="pulse lightning" style="color: #a0522d; font-size: 22px; font-family: 'Butcherman', serif; margin: 20px 0; text-shadow: 2px 2px 0px #3e2723;">★ PRESS SPACE FOR SHOWDOWN! ★</p>
            <p style="font-size: 14px; color: #8b4513; margin-top: 20px; font-style: italic;">~ Sheriff's Department ~ Dodge City, Kansas ~</p>
        </div>
        
        <div class="game-over hidden" id="gameOver">
            <h2 id="gameOverTitle">GAME OVER</h2>
            <p id="finalScore">Final Score: 0</p>
            <p class="pulse">🤠 Press <strong>SPACE</strong> to saddle up again</p>
            <p style="color: #888; font-size: 14px; margin-top: 20px;">Press <strong>H</strong> to view high scores</p>
        </div>
        
        <div class="start-screen hidden" id="highScoresScreen" style="max-width: 600px;">
            <h2 style="color: #daa520; font-size: 36px; margin-bottom: 30px; text-shadow: 2px 2px 4px #8b4513, 0 0 15px rgba(218, 165, 32, 0.5);">
                🤠 HALL OF FAME 🤠
            </h2>
            <div id="highScoresList" style="text-align: left; margin: 20px 0; max-height: 400px; overflow-y: auto;">
                <!-- High scores will be populated here -->
            </div>
            <p style="color: #cd853f; font-size: 14px; margin-top: 30px; text-shadow: 1px 1px 2px #8b4513;">Press <strong>SPACE</strong> to mosey on back</p>
        </div>

        <div class="level-info">
            <span id="levelValue">LEVEL 1</span> • <span id="multiplierValue">x1</span>
        </div>

        <div class="combo-display" id="comboDisplay">
            🔥 COMBO: <span id="comboValue">0</span>
        </div>

        <div class="powerup-display" id="powerupDisplay">
        </div>

        <div class="game-ui">
            <div class="score">Score: <span id="scoreValue">0</span></div>
            <div class="lives">Lives: <span id="livesValue">3</span></div>
        </div>

        <canvas id="gameCanvas"></canvas>
        
        
        <button id="installBtn" onclick="installApp()" style="display: none; position: absolute; top: 10px; right: 100px; background: linear-gradient(45deg, #daa520, #8b4513); border: none; padding: 10px 20px; border-radius: 15px; color: #f5deb3; font-weight: bold; font-size: 12px; cursor: pointer; z-index: 1000; border: 2px solid #cd853f;">🤠 SADDLE UP!</button>
    </div>

    <script>
        class SuperBreakout {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.startScreen = document.getElementById('startScreen');
                this.gameOverScreen = document.getElementById('gameOver');
                this.scoreElement = document.getElementById('scoreValue');
                this.livesElement = document.getElementById('livesValue');
                this.finalScoreElement = document.getElementById('finalScore');
                this.gameOverTitle = document.getElementById('gameOverTitle');
                this.levelElement = document.getElementById('levelValue');
                this.multiplierElement = document.getElementById('multiplierValue');
                this.comboElement = document.getElementById('comboValue');
                this.comboDisplay = document.getElementById('comboDisplay');
                this.powerupDisplay = document.getElementById('powerupDisplay');
                this.playerNameInput = document.getElementById('playerName');
                this.highScoresScreen = document.getElementById('highScoresScreen');
                this.highScoresList = document.getElementById('highScoresList');
                
                this.setupAudio();
                this.loadHighScores();
                
                this.gameState = 'start';
                this.score = 0;
                this.lives = 3;
                this.level = 1;
                this.combo = 0;
                this.maxCombo = 0;
                this.multiplier = 1;
                this.powerUps = [];
                this.particles = [];
                this.trails = [];
                this.screenShake = { x: 0, y: 0, intensity: 0, duration: 0 };
                this.specialEffects = [];
                this.lasers = [];
                this.lightning = [];
                this.timeScale = 1.0;
                this.bulletTime = false;
                this.balls = [];
                this.enemies = [];
                this.boss = null;
                this.ultimateCharge = 0;
                this.obstacles = [];
                this.achievements = [];
                this.explosions = [];
                this.shockwaves = [];
                this.photonicBlasts = [];
                this.magneticFields = [];
                this.wormholes = [];
                this.quantumRifts = [];
                this.chromaticDistortions = [];
                this.dimensionalFragments = [];
                this.energyWaves = [];
                
                this.resizeCanvas();
                this.initializeGame();
                this.setupEventListeners();
                this.initializeAchievements();
                this.initializeSocialFeatures();
                this.initializePerformanceMonitoring();
                this.gameLoop();
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                    this.initializeGame();
                });
            }

            initializeGame() {
                const scale = Math.min(this.canvas.width, this.canvas.height) / 800;
                
                this.paddle = {
                    x: this.canvas.width / 2 - 60 * scale,
                    y: this.canvas.height - 50 * scale,
                    width: 120 * scale,
                    height: 15 * scale,
                    speed: 8 * scale,
                    color: '#8b4513', // Western saddle brown
                    powerUps: {
                        wide: 0,
                        fast: 0,
                        sticky: 0,
                        laser: 0
                    }
                };

                this.ball = {
                    x: this.canvas.width / 2,
                    y: this.canvas.height / 2,
                    radius: 6 * scale,
                    speedX: 3 * scale,
                    speedY: -3 * scale,
                    color: '#ffffff',
                    trail: [],
                    powerUps: {
                        fire: 0,
                        pierce: 0,
                        multi: 0
                    }
                };
                
                this.balls = [this.ball];

                this.createBricks();
                this.combo = 0;
                this.multiplier = 1;

                this.keys = {
                    left: false,
                    right: false,
                    space: false
                };
            }

            createBricks() {
                if (this.level % 5 === 0) {
                    this.createBossLevel();
                    return;
                }
                
                this.bricks = [];
                
                // Different layouts for each level
                const layouts = [
                    this.createClassicLayout.bind(this),
                    this.createPyramidLayout.bind(this),
                    this.createDiamondLayout.bind(this),
                    this.createWaveLayout.bind(this),
                    this.createCheckeredLayout.bind(this),
                    this.createCircleLayout.bind(this),
                    this.createCrossLayout.bind(this),
                    this.createHeartLayout.bind(this),
                    this.createSpiralLayout.bind(this),
                    this.createRandomClusters.bind(this)
                ];
                
                const layoutIndex = (this.level - 1) % layouts.length;
                layouts[layoutIndex]();
            }
            
            createClassicLayout() {
                const scale = Math.min(this.canvas.width, this.canvas.height) / 800;
                const brickRows = 6 + Math.floor(this.level / 3); // Start with fewer rows
                const brickCols = Math.floor(this.canvas.width / (60 * scale));
                const brickWidth = (this.canvas.width - (brickCols + 1) * 4 * scale) / brickCols;
                const brickHeight = 20 * scale;
                const brickPadding = 4 * scale;
                const brickOffsetTop = 80 * scale;
                const brickOffsetLeft = brickPadding;

                const colors = ['#8b4513', '#daa520', '#cd853f', '#d2691e', '#bc8f8f', '#a0522d']; // Western browns and golds

                for (let row = 0; row < brickRows; row++) {
                    for (let col = 0; col < brickCols; col++) {
                        const hits = this.calculateHits(row, brickRows);
                        const type = this.getBrickType(row, brickRows);
                        
                        this.bricks.push({
                            x: brickOffsetLeft + col * (brickWidth + brickPadding),
                            y: brickOffsetTop + row * (brickHeight + brickPadding),
                            width: brickWidth,
                            height: brickHeight,
                            color: colors[row % colors.length],
                            visible: true,
                            points: (brickRows - row) * 10 * this.level,
                            type: type,
                            hits: hits,
                            maxHits: hits,
                            glowIntensity: 0
                        });
                    }
                }
            }
            
            createPyramidLayout() {
                const scale = Math.min(this.canvas.width, this.canvas.height) / 800;
                const brickRows = 8 + Math.floor(this.level / 4);
                const maxCols = Math.floor(this.canvas.width / (60 * scale));
                const brickHeight = 20 * scale;
                const brickPadding = 4 * scale;
                const brickOffsetTop = 80 * scale;
                
                const colors = ['#8b4513', '#daa520', '#cd853f', '#d2691e', '#bc8f8f', '#a0522d']; // Western browns and golds
                
                for (let row = 0; row < brickRows; row++) {
                    const colsInRow = Math.min(row + 1, maxCols);
                    const brickWidth = (this.canvas.width - (colsInRow + 1) * brickPadding) / colsInRow;
                    const startX = (this.canvas.width - (colsInRow * (brickWidth + brickPadding) - brickPadding)) / 2;
                    
                    for (let col = 0; col < colsInRow; col++) {
                        const hits = this.calculateHits(row, brickRows);
                        const type = this.getBrickType(row, brickRows);
                        
                        this.bricks.push({
                            x: startX + col * (brickWidth + brickPadding),
                            y: brickOffsetTop + row * (brickHeight + brickPadding),
                            width: brickWidth,
                            height: brickHeight,
                            color: colors[row % colors.length],
                            visible: true,
                            points: (brickRows - row) * 10 * this.level,
                            type: type,
                            hits: hits,
                            maxHits: hits,
                            glowIntensity: 0
                        });
                    }
                }
            }
            
            createDiamondLayout() {
                const scale = Math.min(this.canvas.width, this.canvas.height) / 800;
                const totalRows = 12 + Math.floor(this.level / 3);
                const maxCols = Math.floor(this.canvas.width / (60 * scale));
                const brickHeight = 20 * scale;
                const brickPadding = 4 * scale;
                const brickOffsetTop = 80 * scale;
                
                const colors = ['#8b4513', '#daa520', '#cd853f', '#d2691e', '#bc8f8f', '#a0522d']; // Western browns and golds
                const midRow = Math.floor(totalRows / 2);
                
                for (let row = 0; row < totalRows; row++) {
                    const distFromMid = Math.abs(row - midRow);
                    const colsInRow = Math.max(1, Math.min(maxCols - distFromMid * 2, maxCols));
                    const brickWidth = (this.canvas.width * 0.8 - (colsInRow + 1) * brickPadding) / colsInRow;
                    const startX = (this.canvas.width - (colsInRow * (brickWidth + brickPadding) - brickPadding)) / 2;
                    
                    for (let col = 0; col < colsInRow; col++) {
                        const hits = this.calculateHits(row, totalRows);
                        const type = this.getBrickType(row, totalRows);
                        
                        this.bricks.push({
                            x: startX + col * (brickWidth + brickPadding),
                            y: brickOffsetTop + row * (brickHeight + brickPadding),
                            width: brickWidth,
                            height: brickHeight,
                            color: colors[row % colors.length],
                            visible: true,
                            points: (totalRows - row) * 10 * this.level,
                            type: type,
                            hits: hits,
                            maxHits: hits,
                            glowIntensity: 0
                        });
                    }
                }
            }
            
            createWaveLayout() {
                const scale = Math.min(this.canvas.width, this.canvas.height) / 800;
                const brickRows = 8 + Math.floor(this.level / 3);
                const brickCols = Math.floor(this.canvas.width / (60 * scale));
                const brickWidth = (this.canvas.width - (brickCols + 1) * 4 * scale) / brickCols;
                const brickHeight = 20 * scale;
                const brickPadding = 4 * scale;
                const brickOffsetTop = 80 * scale;
                const brickOffsetLeft = brickPadding;
                
                const colors = ['#8b4513', '#daa520', '#cd853f', '#d2691e', '#bc8f8f', '#a0522d']; // Western browns and golds
                
                for (let row = 0; row < brickRows; row++) {
                    for (let col = 0; col < brickCols; col++) {
                        const waveOffset = Math.sin(col * 0.5) * 30 * scale;
                        const hits = this.calculateHits(row, brickRows);
                        const type = this.getBrickType(row, brickRows);
                        
                        this.bricks.push({
                            x: brickOffsetLeft + col * (brickWidth + brickPadding),
                            y: brickOffsetTop + row * (brickHeight + brickPadding) + waveOffset,
                            width: brickWidth,
                            height: brickHeight,
                            color: colors[row % colors.length],
                            visible: true,
                            points: (brickRows - row) * 10 * this.level,
                            type: type,
                            hits: hits,
                            maxHits: hits,
                            glowIntensity: 0
                        });
                    }
                }
            }
            
            createCheckeredLayout() {
                const scale = Math.min(this.canvas.width, this.canvas.height) / 800;
                const brickRows = 10 + Math.floor(this.level / 3);
                const brickCols = Math.floor(this.canvas.width / (60 * scale));
                const brickWidth = (this.canvas.width - (brickCols + 1) * 4 * scale) / brickCols;
                const brickHeight = 20 * scale;
                const brickPadding = 4 * scale;
                const brickOffsetTop = 80 * scale;
                const brickOffsetLeft = brickPadding;
                
                const colors = ['#8b4513', '#daa520', '#cd853f', '#d2691e', '#bc8f8f', '#a0522d']; // Western browns and golds
                
                for (let row = 0; row < brickRows; row++) {
                    for (let col = 0; col < brickCols; col++) {
                        if ((row + col) % 2 === 0) {
                            const hits = this.calculateHits(row, brickRows);
                            const type = this.getBrickType(row, brickRows);
                            
                            this.bricks.push({
                                x: brickOffsetLeft + col * (brickWidth + brickPadding),
                                y: brickOffsetTop + row * (brickHeight + brickPadding),
                                width: brickWidth,
                                height: brickHeight,
                                color: colors[row % colors.length],
                                visible: true,
                                points: (brickRows - row) * 10 * this.level,
                                type: type,
                                hits: hits,
                                maxHits: hits,
                                glowIntensity: 0
                            });
                        }
                    }
                }
            }
            
            createCircleLayout() {
                const centerX = this.canvas.width / 2;
                const centerY = 200;
                const maxRadius = Math.min(this.canvas.width, this.canvas.height) * 0.3;
                const rings = 5 + Math.floor(this.level / 4);
                const scale = Math.min(this.canvas.width, this.canvas.height) / 800;
                const brickWidth = 50 * scale;
                const brickHeight = 20 * scale;
                
                const colors = ['#8b4513', '#daa520', '#cd853f', '#d2691e', '#bc8f8f', '#a0522d']; // Western browns and golds
                
                for (let ring = 1; ring <= rings; ring++) {
                    const radius = (maxRadius / rings) * ring;
                    const circumference = 2 * Math.PI * radius;
                    const bricksInRing = Math.floor(circumference / (brickWidth + 5));
                    
                    for (let i = 0; i < bricksInRing; i++) {
                        const angle = (2 * Math.PI / bricksInRing) * i;
                        const x = centerX + Math.cos(angle) * radius - brickWidth / 2;
                        const y = centerY + Math.sin(angle) * radius - brickHeight / 2;
                        
                        const hits = this.calculateHits(ring - 1, rings);
                        const type = this.getBrickType(ring - 1, rings);
                        
                        this.bricks.push({
                            x: x,
                            y: y,
                            width: brickWidth,
                            height: brickHeight,
                            color: colors[(ring - 1) % colors.length],
                            visible: true,
                            points: (rings - ring + 1) * 10 * this.level,
                            type: type,
                            hits: hits,
                            maxHits: hits,
                            glowIntensity: 0
                        });
                    }
                }
            }
            
            createCrossLayout() {
                const scale = Math.min(this.canvas.width, this.canvas.height) / 800;
                const brickRows = 12 + Math.floor(this.level / 3);
                const brickCols = Math.floor(this.canvas.width / (60 * scale));
                const brickWidth = (this.canvas.width - (brickCols + 1) * 4 * scale) / brickCols;
                const brickHeight = 20 * scale;
                const brickPadding = 4 * scale;
                const brickOffsetTop = 80 * scale;
                const brickOffsetLeft = brickPadding;
                
                const colors = ['#8b4513', '#daa520', '#cd853f', '#d2691e', '#bc8f8f', '#a0522d']; // Western browns and golds
                const midCol = Math.floor(brickCols / 2);
                const midRow = Math.floor(brickRows / 2);
                const thickness = 3;
                
                for (let row = 0; row < brickRows; row++) {
                    for (let col = 0; col < brickCols; col++) {
                        const inVertical = Math.abs(col - midCol) < thickness;
                        const inHorizontal = Math.abs(row - midRow) < thickness;
                        
                        if (inVertical || inHorizontal) {
                            const hits = this.calculateHits(row, brickRows);
                            const type = this.getBrickType(row, brickRows);
                            
                            this.bricks.push({
                                x: brickOffsetLeft + col * (brickWidth + brickPadding),
                                y: brickOffsetTop + row * (brickHeight + brickPadding),
                                width: brickWidth,
                                height: brickHeight,
                                color: colors[row % colors.length],
                                visible: true,
                                points: (brickRows - row) * 10 * this.level,
                                type: type,
                                hits: hits,
                                maxHits: hits,
                                glowIntensity: 0
                            });
                        }
                    }
                }
            }
            
            createHeartLayout() {
                const scale = Math.min(this.canvas.width, this.canvas.height) / 800;
                const brickWidth = 40 * scale;
                const brickHeight = 20 * scale;
                const centerX = this.canvas.width / 2;
                const startY = 100 * scale;
                
                const colors = ['#ff0066', '#ff3399', '#ff66cc', '#ff99ff'];
                const heartPoints = [];
                
                // Generate heart shape points
                for (let t = 0; t < Math.PI * 2; t += 0.1) {
                    const x = 16 * Math.pow(Math.sin(t), 3);
                    const y = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                    heartPoints.push({x: x * 8 * scale, y: y * 8 * scale});
                }
                
                heartPoints.forEach((point, index) => {
                    const hits = 1;
                    const type = index % 10 === 0 ? 'powerup' : 'normal';
                    
                    this.bricks.push({
                        x: centerX + point.x - brickWidth / 2,
                        y: startY + point.y - brickHeight / 2,
                        width: brickWidth,
                        height: brickHeight,
                        color: colors[index % colors.length],
                        visible: true,
                        points: 50 * this.level,
                        type: type,
                        hits: hits,
                        maxHits: hits,
                        glowIntensity: 0
                    });
                });
            }
            
            createSpiralLayout() {
                const centerX = this.canvas.width / 2;
                const centerY = 250;
                const scale = Math.min(this.canvas.width, this.canvas.height) / 800;
                const brickWidth = 45 * scale;
                const brickHeight = 20 * scale;
                
                const colors = ['#8b4513', '#daa520', '#cd853f', '#d2691e', '#bc8f8f', '#a0522d']; // Western browns and golds
                const numBricks = 50 + this.level * 10;
                
                for (let i = 0; i < numBricks; i++) {
                    const angle = i * 0.3;
                    const radius = 10 + i * 3;
                    const x = centerX + Math.cos(angle) * radius * scale - brickWidth / 2;
                    const y = centerY + Math.sin(angle) * radius * scale - brickHeight / 2;
                    
                    if (x > 0 && x < this.canvas.width - brickWidth && y > 60 && y < this.canvas.height - 200) {
                        const hits = this.calculateHits(Math.floor(i / 10), Math.floor(numBricks / 10));
                        const type = this.getBrickType(Math.floor(i / 10), Math.floor(numBricks / 10));
                        
                        this.bricks.push({
                            x: x,
                            y: y,
                            width: brickWidth,
                            height: brickHeight,
                            color: colors[i % colors.length],
                            visible: true,
                            points: 20 * this.level,
                            type: type,
                            hits: hits,
                            maxHits: hits,
                            glowIntensity: 0
                        });
                    }
                }
            }
            
            createRandomClusters() {
                const scale = Math.min(this.canvas.width, this.canvas.height) / 800;
                const brickWidth = 50 * scale;
                const brickHeight = 20 * scale;
                const colors = ['#8b4513', '#daa520', '#cd853f', '#d2691e', '#bc8f8f', '#a0522d']; // Western browns and golds
                
                const numClusters = 5 + Math.floor(this.level / 2);
                const bricksPerCluster = 10 + Math.floor(this.level * 2);
                
                for (let cluster = 0; cluster < numClusters; cluster++) {
                    const clusterX = Math.random() * (this.canvas.width - 200) + 100;
                    const clusterY = Math.random() * 200 + 80;
                    
                    for (let i = 0; i < bricksPerCluster; i++) {
                        const offsetX = (Math.random() - 0.5) * 150 * scale;
                        const offsetY = (Math.random() - 0.5) * 100 * scale;
                        const x = clusterX + offsetX;
                        const y = clusterY + offsetY;
                        
                        if (x > 0 && x < this.canvas.width - brickWidth && y > 60 && y < this.canvas.height - 300) {
                            const hits = this.calculateHits(cluster, numClusters);
                            const type = this.getBrickType(cluster, numClusters);
                            
                            this.bricks.push({
                                x: x,
                                y: y,
                                width: brickWidth,
                                height: brickHeight,
                                color: colors[cluster % colors.length],
                                visible: true,
                                points: 30 * this.level,
                                type: type,
                                hits: hits,
                                maxHits: hits,
                                glowIntensity: 0
                            });
                        }
                    }
                }
            }
            
            calculateHits(row, totalRows) {
                // Easy on early levels, harder on later levels
                if (this.level === 1) return 1;
                if (this.level === 2) return row < totalRows / 2 ? 1 : 2;
                if (this.level === 3) return row < totalRows / 3 ? 1 : row < totalRows * 2/3 ? 2 : 3;
                
                // Progressive difficulty
                const baseHits = 1 + Math.floor(row / (totalRows / this.level));
                return Math.min(baseHits, 5);
            }
            
            getBrickType(row, totalRows) {
                const rand = Math.random();
                const difficultyFactor = this.level * 0.02;
                
                // More special bricks on higher levels
                if (rand < 0.05 + difficultyFactor) return 'treasure';
                if (rand < 0.1 + difficultyFactor) return 'powerup';
                if (rand < 0.12 + difficultyFactor) return 'explosive';
                if (row < totalRows / 3 && rand < 0.15 + difficultyFactor) return 'armored';
                
                return 'normal';
            }

            createBossLevel() {
                this.bricks = [];
                const scale = Math.min(this.canvas.width, this.canvas.height) / 800;
                const centerX = this.canvas.width / 2;
                const centerY = 200 * scale;
                
                this.boss = {
                    x: centerX - 100 * scale,
                    y: 50 * scale,
                    width: 200 * scale,
                    height: 100 * scale,
                    health: 50 + this.level * 10,
                    maxHealth: 50 + this.level * 10,
                    active: true,
                    phase: 1,
                    angle: 0,
                    color: '#a0522d'
                };
                
                for (let i = 0; i < 5; i++) {
                    for (let j = 0; j < 3; j++) {
                        this.bricks.push({
                            x: centerX - 100 * scale + i * 40 * scale,
                            y: centerY + j * 25 * scale + 50,
                            width: 35 * scale,
                            height: 20 * scale,
                            color: '#ff0000',
                            visible: true,
                            points: 100 * this.level,
                            type: 'armored',
                            hits: 3,
                            maxHits: 3,
                            glowIntensity: 0
                        });
                    }
                }
            }

            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    switch(e.code) {
                        case 'ArrowLeft':
                        case 'KeyA':
                            this.keys.left = true;
                            break;
                        case 'ArrowRight':
                        case 'KeyD':
                            this.keys.right = true;
                            break;
                        case 'Space':
                            e.preventDefault();
                            this.handleSpaceKey();
                            break;
                        case 'KeyR':
                            this.resetGame();
                            break;
                        case 'KeyH':
                            if (this.gameState === 'gameOver' || this.gameState === 'won') {
                                this.showHighScores();
                            } else if (this.gameState === 'highScores') {
                                this.hideHighScores();
                            }
                            break;
                        case 'KeyX':
                            this.activateBulletTime();
                            break;
                        case 'KeyC':
                            this.fireLaser();
                            break;
                        case 'KeyP':
                        case 'Escape':
                            if (this.gameState === 'playing') {
                                this.pauseGame();
                            } else if (this.gameState === 'paused') {
                                this.resumeGame();
                            }
                            break;
                    }
                });

                document.addEventListener('keyup', (e) => {
                    switch(e.code) {
                        case 'ArrowLeft':
                        case 'KeyA':
                            this.keys.left = false;
                            break;
                        case 'ArrowRight':
                        case 'KeyD':
                            this.keys.right = false;
                            break;
                    }
                });
            }

            handleSpaceKey() {
                if (this.gameState === 'playing') {
                    if (this.ultimateCharge >= 100) {
                        this.activateUltimate();
                    }
                    return;
                }
                
                switch(this.gameState) {
                    case 'start':
                        this.startGame();
                        break;
                    case 'paused':
                        this.resumeGame();
                        break;
                    case 'gameOver':
                    case 'won':
                        this.resetGame();
                        break;
                    case 'highScores':
                        this.hideHighScores();
                        break;
                }
            }

            startGame() {
                this.gameState = 'playing';
                this.startScreen.classList.add('hidden');
            }

            pauseGame() {
                this.gameState = 'paused';
            }

            resumeGame() {
                this.gameState = 'playing';
            }

            resetGame() {
                this.score = 0;
                this.lives = 3;
                this.level = 1;
                this.combo = 0;
                this.multiplier = 1;
                this.gameState = 'start';
                this.startScreen.classList.remove('hidden');
                this.gameOverScreen.classList.add('hidden');
                this.highScoresScreen.classList.add('hidden');
                
                // Clear any win styling
                this.gameOverTitle.classList.remove('win');
                
                this.updateUI();
                this.initializeGame();
            }
            
            initializeAchievements() {
                this.achievementDefinitions = {
                    'first_blood': { name: 'First Draw', description: 'Destroy your first target', icon: '🔫', unlocked: false },
                    'combo_master': { name: 'Gunslinger', description: 'Achieve a 20+ combo streak', icon: '🔥', unlocked: false },
                    'level_10': { name: 'Frontier Marshal', description: 'Reach level 10 in the Wild West', icon: '🤠', unlocked: false },
                    'boss_slayer': { name: 'Outlaw Hunter', description: 'Defeat your first gang boss', icon: '👑', unlocked: false },
                    'power_collector': { name: 'Treasure Prospector', description: 'Collect 50 power-ups', icon: '💰', unlocked: false },
                    'quantum_leap': { name: 'Ghost Rider', description: 'Use ghost bullet power-up', icon: '👻', unlocked: false },
                    'ultimate_master': { name: 'High Noon Legend', description: 'Use showdown ability 25 times', icon: '☀️', unlocked: false },
                    'survivor': { name: 'Desert Survivor', description: 'Survive 10 minutes in the wasteland', icon: '🌵', unlocked: false },
                    'millionaire': { name: 'Gold Rush Baron', description: 'Strike it rich with 1,000,000 points', icon: '🪙', unlocked: false },
                    'perfectionist': { name: 'Sharpshooter', description: 'Clear a level without missing', icon: '🎯', unlocked: false },
                    'portal_jumper': { name: 'Mine Cart Rider', description: 'Use mine shaft portal', icon: '⛏️', unlocked: false },
                    'time_lord': { name: 'Quickdraw Master', description: 'Enter showdown mode 10 times', icon: '⏱️', unlocked: false }
                };
                
                // Load achievements from localStorage
                const saved = localStorage.getItem('cyberBreakoutAchievements');
                if (saved) {
                    try {
                        const savedAchievements = JSON.parse(saved);
                        Object.keys(savedAchievements).forEach(key => {
                            if (this.achievementDefinitions[key]) {
                                this.achievementDefinitions[key].unlocked = savedAchievements[key].unlocked;
                            }
                        });
                    } catch (e) {
                        console.log('Could not load achievements');
                    }
                }
                
                this.playerStats = {
                    bricksDestroyed: 0,
                    powerUpsCollected: 0,
                    ultimatesUsed: 0,
                    bossesDefeated: 0,
                    bulletTimeUses: 0,
                    portalUses: 0,
                    quantumUses: 0,
                    playTime: 0,
                    perfectLevels: 0,
                    missedBalls: 0
                };
                
                // Load stats
                const savedStats = localStorage.getItem('cyberBreakoutStats');
                if (savedStats) {
                    try {
                        this.playerStats = {...this.playerStats, ...JSON.parse(savedStats)};
                    } catch (e) {
                        console.log('Could not load stats');
                    }
                }
            }
            
            checkAchievements() {
                if (!this.achievementDefinitions) return;
                
                const toUnlock = [];
                
                if (!this.achievementDefinitions.first_blood.unlocked && this.playerStats.bricksDestroyed >= 1) {
                    toUnlock.push('first_blood');
                }
                if (!this.achievementDefinitions.combo_master.unlocked && this.maxCombo >= 20) {
                    toUnlock.push('combo_master');
                }
                if (!this.achievementDefinitions.level_10.unlocked && this.level >= 10) {
                    toUnlock.push('level_10');
                }
                if (!this.achievementDefinitions.boss_slayer.unlocked && this.playerStats.bossesDefeated >= 1) {
                    toUnlock.push('boss_slayer');
                }
                if (!this.achievementDefinitions.power_collector.unlocked && this.playerStats.powerUpsCollected >= 50) {
                    toUnlock.push('power_collector');
                }
                if (!this.achievementDefinitions.ultimate_master.unlocked && this.playerStats.ultimatesUsed >= 25) {
                    toUnlock.push('ultimate_master');
                }
                if (!this.achievementDefinitions.millionaire.unlocked && this.score >= 1000000) {
                    toUnlock.push('millionaire');
                }
                if (!this.achievementDefinitions.quantum_leap.unlocked && this.playerStats.quantumUses >= 1) {
                    toUnlock.push('quantum_leap');
                }
                if (!this.achievementDefinitions.portal_jumper.unlocked && this.playerStats.portalUses >= 1) {
                    toUnlock.push('portal_jumper');
                }
                if (!this.achievementDefinitions.time_lord.unlocked && this.playerStats.bulletTimeUses >= 10) {
                    toUnlock.push('time_lord');
                }
                
                toUnlock.forEach(achievementId => {
                    this.unlockAchievement(achievementId);
                });
            }
            
            unlockAchievement(achievementId) {
                if (this.achievementDefinitions[achievementId] && !this.achievementDefinitions[achievementId].unlocked) {
                    this.achievementDefinitions[achievementId].unlocked = true;
                    this.showAchievementNotification(this.achievementDefinitions[achievementId]);
                    
                    // Save achievements
                    localStorage.setItem('cyberBreakoutAchievements', JSON.stringify(this.achievementDefinitions));
                    
                    // Play achievement sound
                    if (this.sounds && this.sounds.powerup) {
                        this.sounds.powerup();
                    }
                }
            }
            
            showAchievementNotification(achievement) {
                const notification = document.createElement('div');
                notification.innerHTML = `
                    <div style="position: fixed; top: 20px; right: 20px; z-index: 10000; 
                                background: linear-gradient(135deg, rgba(255, 215, 0, 0.95), rgba(255, 140, 0, 0.95)); 
                                color: #000; padding: 15px 20px; border-radius: 10px; 
                                font-family: 'Orbitron', monospace; font-weight: bold; 
                                box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
                                animation: achievementSlide 0.5s ease-out, achievementGlow 1s ease-in-out infinite alternate;">
                        <div style="font-size: 24px; margin-bottom: 5px;">${achievement.icon} ACHIEVEMENT UNLOCKED!</div>
                        <div style="font-size: 16px;">${achievement.name}</div>
                        <div style="font-size: 12px; opacity: 0.8;">${achievement.description}</div>
                    </div>
                `;
                
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.style.animation = 'achievementSlideOut 0.5s ease-in';
                    setTimeout(() => {
                        if (document.body.contains(notification)) {
                            document.body.removeChild(notification);
                        }
                    }, 500);
                }, 4000);
            }
            
            initializeSocialFeatures() {
                this.shareData = {
                    title: 'Gunslinger\'s Breakout: Wild West Showdown',
                    text: 'Saddle up partner! Check out this rootin\' tootin\' western breakout game!',
                    url: window.location.href
                };
            }
            
            shareScore(score, level) {
                const shareText = `🤠 I just struck ${score.toLocaleString()} gold and conquered level ${level} in Gunslinger's Breakout: Wild West Showdown! 🔫☀️`;
                
                if (navigator.share) {
                    navigator.share({
                        title: this.shareData.title,
                        text: shareText,
                        url: this.shareData.url
                    }).catch(err => console.log('Error sharing:', err));
                } else {
                    // Fallback: copy to clipboard
                    const textArea = document.createElement('textarea');
                    textArea.value = `${shareText} ${this.shareData.url}`;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    
                    this.showNotification('Score copied to clipboard! 📋');
                }
            }
            
            showNotification(message) {
                const notification = document.createElement('div');
                notification.innerHTML = `
                    <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                                z-index: 10000; background: rgba(0, 0, 0, 0.9); color: #00ffff; 
                                padding: 20px; border-radius: 10px; font-family: 'Orbitron', monospace; 
                                border: 2px solid #00ffff; text-align: center;
                                animation: notificationPulse 0.3s ease-out;">
                        ${message}
                    </div>
                `;
                
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                    }
                }, 2000);
            }

            update() {
                if (this.gameState !== 'playing') return;

                this.updatePaddle();
                this.updateBall();
                this.updateAllBalls();
                this.updateEnemies();
                this.updateBoss();
                this.updateObstacles();
                this.updateParticles();
                this.updatePowerUps();
                this.updateScreenShake();
                this.updateSpecialEffects();
                this.updateLasers();
                this.updateLightning();
                this.updateAdvancedEffects();
                this.updateTimeEffects();
                this.updatePortals();
                this.checkCollisions();
                this.checkGameState();
                this.updateUltimate();
                
                // Check achievements
                if (this.checkAchievements) {
                    this.checkAchievements();
                }
                
                // Update stats for achievements
                if (this.playerStats) {
                    if (!this.gameStartTime) {
                        this.gameStartTime = Date.now();
                    }
                    this.playerStats.playTime = Date.now() - this.gameStartTime;
                    
                    // Save stats periodically
                    if (Date.now() - (this.lastStatsSave || 0) > 10000) {
                        localStorage.setItem('cyberBreakoutStats', JSON.stringify(this.playerStats));
                        this.lastStatsSave = Date.now();
                    }
                }
            }

            updatePaddle() {
                // AI Assistance when active
                if (this.aiAssist && Date.now() < this.aiAssist) {
                    this.applyAIAssistance();
                } else {
                    // Manual control
                    if (this.keys.left && this.paddle.x > 0) {
                        this.paddle.x -= this.paddle.speed;
                    }
                    if (this.keys.right && this.paddle.x < this.canvas.width - this.paddle.width) {
                        this.paddle.x += this.paddle.speed;
                    }
                }
                
                // Magnetic paddle effect
                if (this.paddle.powerUps.magnet && this.paddle.powerUps.magnet > Date.now()) {
                    this.applyMagneticEffect();
                }
                
                // Dynamic difficulty adjustment
                this.updateDifficulty();
            }
            
            applyAIAssistance() {
                // Find closest ball
                let closestBall = this.balls[0];
                let minDistance = Infinity;
                
                for (let ball of this.balls) {
                    if (ball.speedY > 0) { // Ball moving downward
                        const distance = Math.abs(ball.y - this.paddle.y);
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestBall = ball;
                        }
                    }
                }
                
                if (closestBall && closestBall.speedY > 0) {
                    // Predict ball position
                    const timeToReach = (this.paddle.y - closestBall.y) / closestBall.speedY;
                    const predictedX = closestBall.x + (closestBall.speedX * timeToReach);
                    
                    // AI paddle movement with slight imperfection for fairness
                    const targetX = predictedX - this.paddle.width / 2;
                    const aiAccuracy = 0.85; // 85% accuracy
                    const adjustedTargetX = targetX + (Math.random() - 0.5) * this.paddle.width * (1 - aiAccuracy);
                    
                    const paddleCenter = this.paddle.x + this.paddle.width / 2;
                    const diff = adjustedTargetX - paddleCenter;
                    
                    if (Math.abs(diff) > 5) {
                        const moveSpeed = this.paddle.speed * 0.7; // AI moves slightly slower
                        if (diff > 0 && this.paddle.x < this.canvas.width - this.paddle.width) {
                            this.paddle.x += Math.min(moveSpeed, diff);
                        } else if (diff < 0 && this.paddle.x > 0) {
                            this.paddle.x -= Math.min(moveSpeed, Math.abs(diff));
                        }
                    }
                }
                
                // Manual override still works
                if (this.keys.left && this.paddle.x > 0) {
                    this.paddle.x -= this.paddle.speed * 0.3;
                }
                if (this.keys.right && this.paddle.x < this.canvas.width - this.paddle.width) {
                    this.paddle.x += this.paddle.speed * 0.3;
                }
            }
            
            applyMagneticEffect() {
                for (let ball of this.balls) {
                    const dx = (this.paddle.x + this.paddle.width / 2) - ball.x;
                    const dy = this.paddle.y - ball.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 100 && ball.speedY > 0) {
                        const force = (100 - distance) / 100;
                        ball.speedX += (dx / distance) * force * 0.3;
                        ball.speedY += (dy / distance) * force * 0.3;
                    }
                }
            }
            
            updateDifficulty() {
                // Adaptive difficulty based on performance
                const currentTime = Date.now();
                if (!this.lastDifficultyUpdate) {
                    this.lastDifficultyUpdate = currentTime;
                    this.playerSkillLevel = 1.0;
                    this.performanceHistory = [];
                    return;
                }
                
                if (currentTime - this.lastDifficultyUpdate > 30000) { // Every 30 seconds
                    const recentPerformance = {
                        score: this.score,
                        combo: this.maxCombo,
                        livesLost: 3 - this.lives,
                        timeAlive: currentTime - this.gameStartTime
                    };
                    
                    this.performanceHistory.push(recentPerformance);
                    if (this.performanceHistory.length > 5) {
                        this.performanceHistory.shift();
                    }
                    
                    // Calculate skill level
                    const avgScore = this.performanceHistory.reduce((sum, p) => sum + p.score, 0) / this.performanceHistory.length;
                    const avgCombo = this.performanceHistory.reduce((sum, p) => sum + p.combo, 0) / this.performanceHistory.length;
                    const avgLivesLost = this.performanceHistory.reduce((sum, p) => sum + p.livesLost, 0) / this.performanceHistory.length;
                    
                    // Adjust difficulty
                    if (avgScore > 50000 && avgCombo > 10 && avgLivesLost < 1) {
                        this.playerSkillLevel = Math.min(3.0, this.playerSkillLevel + 0.1);
                    } else if (avgScore < 10000 || avgLivesLost > 2) {
                        this.playerSkillLevel = Math.max(0.5, this.playerSkillLevel - 0.1);
                    }
                    
                    this.lastDifficultyUpdate = currentTime;
                }
                
                // Apply difficulty scaling
                if (this.playerSkillLevel > 1.5) {
                    // Increase enemy spawn rate for skilled players
                    if (Math.random() < 0.001 * this.playerSkillLevel) {
                        this.spawnEnemy();
                    }
                } else if (this.playerSkillLevel < 0.8) {
                    // Provide assistance for struggling players
                    if (Math.random() < 0.005 && this.lives <= 1) {
                        this.spawnPowerUp(
                            Math.random() * (this.canvas.width - 60) + 30,
                            50,
                            Math.random() > 0.5 ? 'shield' : 'wide'
                        );
                    }
                }
            }

            updateBall() {
                this.ball.x += this.ball.speedX * this.timeScale;
                this.ball.y += this.ball.speedY * this.timeScale;

                if (this.ball.x <= this.ball.radius || this.ball.x >= this.canvas.width - this.ball.radius) {
                    this.ball.speedX = -this.ball.speedX;
                    this.createParticles(this.ball.x, this.ball.y, '#daa520', 3);
                }
                if (this.ball.y <= this.ball.radius) {
                    this.ball.speedY = -this.ball.speedY;
                    this.createParticles(this.ball.x, this.ball.y, '#daa520', 3);
                }

                if (this.ball.y >= this.canvas.height - this.ball.radius) {
                    if (this.balls.length > 1) {
                        const index = this.balls.indexOf(this.ball);
                        if (index > -1) {
                            this.balls.splice(index, 1);
                            if (this.balls.length > 0) {
                                this.ball = this.balls[0];
                            }
                        }
                    } else {
                        this.lives--;
                        this.combo = 0;
                        this.resetBall();
                        if (this.lives <= 0) {
                            this.gameState = 'gameOver';
                            this.gameOverTitle.textContent = '💀 BOOT HILL 💀';
                            this.finalScoreElement.textContent = `Gold Earned: ${this.score.toLocaleString()}`;
                            
                            // Save high score
                            const playerName = this.getPlayerName();
                            const isNewHigh = this.saveHighScore(playerName, this.score);
                            
                            if (isNewHigh) {
                                this.finalScoreElement.innerHTML = `🏆 NEW HIGH SCORE! 🏆<br>Final Score: ${this.score.toLocaleString()}<br><br><button onclick="game.shareScore(${this.score}, ${this.level})" style="background: linear-gradient(45deg, #ff6600, #ff00ff); border: none; padding: 10px 20px; border-radius: 25px; color: white; font-weight: bold; cursor: pointer; margin-top: 10px;">📢 SHARE SCORE</button>`;
                                this.gameOverTitle.textContent = '⭐ NEW SHERIFF IN TOWN! ⭐';
                                this.gameOverTitle.classList.add('win');
                                
                                // Auto-trigger share for very high scores
                                if (this.score > 500000) {
                                    setTimeout(() => {
                                        if (confirm('🎆 Amazing score! Share your achievement?')) {
                                            this.shareScore(this.score, this.level);
                                        }
                                    }, 2000);
                                }
                            }
                            
                            this.gameOverScreen.classList.remove('hidden');
                        }
                    }
                }
            }
            
            updateAllBalls() {
                for (let i = this.balls.length - 1; i >= 0; i--) {
                    const ball = this.balls[i];
                    if (ball === this.ball) continue;
                    
                    ball.x += ball.speedX * this.timeScale;
                    ball.y += ball.speedY * this.timeScale;

                    if (ball.x <= ball.radius || ball.x >= this.canvas.width - ball.radius) {
                        ball.speedX = -ball.speedX;
                        this.createParticles(ball.x, ball.y, ball.color, 2);
                    }
                    if (ball.y <= ball.radius) {
                        ball.speedY = -ball.speedY;
                        this.createParticles(ball.x, ball.y, ball.color, 2);
                    }

                    if (ball.y >= this.canvas.height - ball.radius) {
                        this.balls.splice(i, 1);
                        this.createParticles(ball.x, ball.y, '#ff0000', 5);
                    }
                }
            }

            checkCollisions() {
                for (let ball of this.balls) {
                    if (ball.y + ball.radius >= this.paddle.y &&
                        ball.x >= this.paddle.x &&
                        ball.x <= this.paddle.x + this.paddle.width &&
                        ball.speedY > 0) {
                        
                        const scale = Math.min(this.canvas.width, this.canvas.height) / 800;
                        const hitPos = (ball.x - (this.paddle.x + this.paddle.width / 2)) / (this.paddle.width / 2);
                        ball.speedX = hitPos * 3 * scale;
                        ball.speedY = -Math.abs(ball.speedY);
                        this.ultimateCharge = Math.min(100, this.ultimateCharge + 2);
                    }

                    for (let brick of this.bricks) {
                        if (!brick.visible) continue;

                        if (ball.x >= brick.x &&
                            ball.x <= brick.x + brick.width &&
                            ball.y >= brick.y &&
                            ball.y <= brick.y + brick.height) {
                            
                            this.hitBrick(brick, ball);
                            if (!ball.powerUps.pierce || ball.powerUps.pierce < Date.now()) {
                                ball.speedY = -ball.speedY;
                            }
                            break;
                        }
                    }
                    
                    for (let enemy of this.enemies) {
                        const dist = Math.sqrt(Math.pow(ball.x - enemy.x, 2) + Math.pow(ball.y - enemy.y, 2));
                        if (dist < ball.radius + enemy.radius) {
                            this.destroyEnemy(enemy);
                            ball.speedY = -ball.speedY;
                        }
                    }
                    
                    if (this.boss && this.boss.active) {
                        if (ball.x >= this.boss.x &&
                            ball.x <= this.boss.x + this.boss.width &&
                            ball.y >= this.boss.y &&
                            ball.y <= this.boss.y + this.boss.height) {
                            
                            this.hitBoss();
                            ball.speedY = -ball.speedY;
                        }
                    }
                }
            }

            checkGameState() {
                const remainingBricks = this.bricks.filter(brick => brick.visible);
                if (remainingBricks.length === 0) {
                    this.levelComplete();
                }
            }

            levelComplete() {
                this.level++;
                this.combo = 0;
                
                const levelBonus = this.level * 1000 * this.multiplier;
                this.score += levelBonus;
                
                for (let i = 0; i < 50; i++) {
                    this.createParticles(
                        Math.random() * this.canvas.width,
                        Math.random() * this.canvas.height / 2,
                        ['#ffd700', '#ff6600', '#00ff88'][Math.floor(Math.random() * 3)],
                        1,
                        'celebration'
                    );
                }
                
                this.addScreenShake(15, 800);
                
                if (this.level > 10) {
                    this.gameState = 'won';
                    this.gameOverTitle.textContent = '🤠 FRONTIER CONQUERED! 🤠';
                    this.gameOverTitle.classList.add('win');
                    
                    // Save high score for game completion
                    const playerName = this.getPlayerName();
                    const isNewHigh = this.saveHighScore(playerName, this.score);
                    
                    if (isNewHigh) {
                        this.finalScoreElement.innerHTML = `🏆 NEW HIGH SCORE! 🏆<br>🎯 Final Score: ${this.score.toLocaleString()}`;
                    } else {
                        this.finalScoreElement.textContent = `🎯 Final Score: ${this.score.toLocaleString()}`;
                    }
                    
                    this.gameOverScreen.classList.remove('hidden');
                } else {
                    setTimeout(() => {
                        this.initializeGame();
                        this.resetBall();
                    }, 2000);
                }
            }

            resetBall() {
                const scale = Math.min(this.canvas.width, this.canvas.height) / 800;
                this.ball.x = this.canvas.width / 2;
                this.ball.y = this.canvas.height / 2;
                this.ball.speedX = (Math.random() > 0.5 ? 1 : -1) * 3 * scale;
                this.ball.speedY = -3 * scale;
                this.balls = [this.ball];
            }

            createParticles(x, y, color, count = 10, type = 'explosion') {
                for (let i = 0; i < count; i++) {
                    const particle = {
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        color: color,
                        size: Math.random() * 4 + 2,
                        life: 1,
                        decay: Math.random() * 0.02 + 0.01,
                        type: type,
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.2,
                        gravity: type === 'spark' ? 0 : 0.1,
                        bounce: type === 'bounce' ? 0.7 : 0,
                        glow: type === 'neon' || type === 'energy',
                        trail: type === 'trail' || type === 'energy'
                    };
                    
                    if (type === 'spiral') {
                        const angle = (i / count) * Math.PI * 2;
                        particle.vx = Math.cos(angle) * 6;
                        particle.vy = Math.sin(angle) * 6;
                        particle.spiralSpeed = 0.1;
                    } else if (type === 'firework') {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = Math.random() * 10 + 5;
                        particle.vx = Math.cos(angle) * speed;
                        particle.vy = Math.sin(angle) * speed;
                        particle.gravity = 0.2;
                    } else if (type === 'energy') {
                        particle.frequency = Math.random() * 0.5 + 0.1;
                        particle.amplitude = Math.random() * 10 + 5;
                        particle.waveOffset = Math.random() * Math.PI * 2;
                    }
                    
                    this.particles.push(particle);
                }
            }
            
            createQuantumParticles(x, y, count = 20) {
                for (let i = 0; i < count; i++) {
                    this.particles.push({
                        x: x + (Math.random() - 0.5) * 20,
                        y: y + (Math.random() - 0.5) * 20,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        color: `hsl(${Math.random() * 60 + 280}, 100%, ${Math.random() * 30 + 70}%)`,
                        size: Math.random() * 2 + 1,
                        life: 1,
                        decay: 0.005,
                        type: 'quantum',
                        phase: Math.random() * Math.PI * 2,
                        frequency: Math.random() * 0.2 + 0.1,
                        opacity: Math.random() * 0.5 + 0.5
                    });
                }
            }
            
            createPhotonicBlast(x, y, power = 1) {
                this.photonicBlasts.push({
                    x: x,
                    y: y,
                    radius: 0,
                    maxRadius: 100 * power,
                    power: power,
                    life: 1,
                    decay: 0.05,
                    rings: Math.floor(power * 3) + 2
                });
                
                this.createParticles(x, y, '#cd853f', 30, 'energy');
            }

            updateParticles() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    
                    if (p.type === 'quantum') {
                        p.phase += p.frequency;
                        p.x += Math.sin(p.phase) * 0.5 + p.vx;
                        p.y += Math.cos(p.phase) * 0.5 + p.vy;
                        p.opacity = Math.sin(p.phase * 2) * 0.3 + 0.7;
                    } else if (p.type === 'energy') {
                        p.waveOffset += p.frequency;
                        p.x += p.vx + Math.sin(p.waveOffset) * p.amplitude * 0.01;
                        p.y += p.vy + Math.cos(p.waveOffset) * p.amplitude * 0.01;
                    } else if (p.type === 'spiral') {
                        p.rotation += p.spiralSpeed;
                        const radius = Math.sqrt(p.vx * p.vx + p.vy * p.vy);
                        p.vx = Math.cos(p.rotation) * radius * 0.98;
                        p.vy = Math.sin(p.rotation) * radius * 0.98;
                        p.x += p.vx;
                        p.y += p.vy;
                    } else {
                        p.x += p.vx;
                        p.y += p.vy;
                        p.vy += p.gravity;
                        
                        if (p.bounce > 0 && p.y > this.canvas.height - p.size) {
                            p.vy *= -p.bounce;
                            p.y = this.canvas.height - p.size;
                        }
                    }
                    
                    if (p.rotation !== undefined) {
                        p.rotation += p.rotationSpeed;
                    }
                    
                    p.life -= p.decay;
                    p.size *= p.type === 'quantum' ? 0.995 : 0.98;
                    
                    if (p.trail) {
                        this.trails.push({
                            x: p.x,
                            y: p.y,
                            size: p.size * 0.3,
                            color: p.color,
                            life: 0.3
                        });
                    }
                    
                    if (p.life <= 0 || p.size < 0.5) {
                        this.particles.splice(i, 1);
                    }
                }
                
                // Update trails
                for (let i = this.trails.length - 1; i >= 0; i--) {
                    const trail = this.trails[i];
                    trail.life -= 0.05;
                    if (trail.life <= 0) {
                        this.trails.splice(i, 1);
                    }
                }
                
                // Update photonic blasts
                for (let i = this.photonicBlasts.length - 1; i >= 0; i--) {
                    const blast = this.photonicBlasts[i];
                    blast.radius = blast.maxRadius * (1 - blast.life);
                    blast.life -= blast.decay;
                    
                    if (blast.life <= 0) {
                        this.photonicBlasts.splice(i, 1);
                    }
                }
            }

            spawnPowerUp(x, y, type) {
                const powerUpTypes = {
                    'wide': { color: '#8b4513', effect: 'Wider Sheriff Badge', duration: 10000 },
                    'multi': { color: '#daa520', effect: 'Split Shot Bullets', duration: 0 },
                    'laser': { color: '#dc143c', effect: 'Six-Shooter Rapid Fire', duration: 8000 },
                    'slow': { color: '#d2691e', effect: 'Whiskey Slow Motion', duration: 5000 },
                    'pierce': { color: '#ffd700', effect: 'Armor Piercing Rounds', duration: 7000 },
                    'shield': { color: '#cd853f', effect: 'Tin Star Shield', duration: 15000 },
                    'magnet': { color: '#b8860b', effect: 'Magnetic Horseshoe', duration: 10000 },
                    'quantum': { color: '#a0522d', effect: 'Ghost Bullet', duration: 12000 },
                    'storm': { color: '#8b7355', effect: 'Thunder Storm', duration: 8000 },
                    'black_hole': { color: '#654321', effect: 'Tornado Twister', duration: 15000 },
                    'time_warp': { color: '#daa520', effect: 'High Noon Showdown', duration: 6000 },
                    'photonic': { color: '#ff6347', effect: 'Dynamite Blaster', duration: 10000 },
                    'dimension': { color: '#deb887', effect: 'Mine Shaft Portal', duration: 8000 },
                    'neural': { color: '#9b870c', effect: 'Deputy Assistance', duration: 20000 },
                    'singularity': { color: '#696969', effect: 'Dust Devil', duration: 5000 }
                };
                
                const selectedType = type || Object.keys(powerUpTypes)[Math.floor(Math.random() * Object.keys(powerUpTypes).length)];
                const powerUpInfo = powerUpTypes[selectedType] || powerUpTypes['multi'];
                
                const powerUp = {
                    x: x,
                    y: y,
                    width: 30,
                    height: 20,
                    type: selectedType,
                    color: powerUpInfo.color,
                    speed: 2,
                    collected: false,
                    pulse: 0
                };
                
                this.powerUps.push(powerUp);
            }

            updatePowerUps() {
                for (let i = this.powerUps.length - 1; i >= 0; i--) {
                    const powerUp = this.powerUps[i];
                    powerUp.y += powerUp.speed;
                    powerUp.pulse += 0.1;
                    
                    if (powerUp.y + powerUp.height >= this.paddle.y &&
                        powerUp.x + powerUp.width >= this.paddle.x &&
                        powerUp.x <= this.paddle.x + this.paddle.width) {
                        this.collectPowerUp(powerUp);
                        this.powerUps.splice(i, 1);
                    } else if (powerUp.y > this.canvas.height) {
                        this.powerUps.splice(i, 1);
                    }
                }
            }

            collectPowerUp(powerUp) {
                this.createParticles(powerUp.x, powerUp.y, powerUp.color, 15, 'powerup');
                this.addScreenShake(8, 300);
                this.ultimateCharge = Math.min(100, this.ultimateCharge + 10);
                
                // Track achievement stats
                if (this.playerStats) {
                    this.playerStats.powerUpsCollected++;
                    
                    // Track specific power-up types
                    if (powerUp.type === 'quantum') this.playerStats.quantumUses++;
                    if (powerUp.type === 'dimension') this.playerStats.portalUses++;
                    if (powerUp.type === 'time_warp') this.playerStats.bulletTimeUses++;
                }
                
                switch (powerUp.type) {
                    case 'wide':
                        this.paddle.width *= 1.5;
                        this.paddle.powerUps.wide = Date.now() + 10000;
                        break;
                    case 'laser':
                        this.paddle.powerUps.laser = Date.now() + 8000;
                        break;
                    case 'slow':
                        this.ball.speedX *= 0.5;
                        this.ball.speedY *= 0.5;
                        break;
                    case 'pierce':
                        this.ball.powerUps.pierce = Date.now() + 7000;
                        break;
                    case 'multi':
                        this.splitBalls();
                        break;
                    case 'shield':
                        this.paddle.powerUps.shield = Date.now() + 15000;
                        break;
                    case 'magnet':
                        this.paddle.powerUps.magnet = Date.now() + 10000;
                        break;
                    case 'quantum':
                        this.ball.powerUps.quantum = Date.now() + 12000;
                        this.createQuantumParticles(powerUp.x, powerUp.y, 30);
                        break;
                    case 'storm':
                        this.activeLightningStorm = Date.now() + 8000;
                        this.createLightningStorm();
                        break;
                    case 'black_hole':
                        this.createBlackHole(powerUp.x, powerUp.y);
                        break;
                    case 'time_warp':
                        this.bulletTime = true;
                        this.timeScale = 0.3;
                        this.bulletTimeEnd = Date.now() + 6000;
                        break;
                    case 'photonic':
                        this.paddle.powerUps.photonic = Date.now() + 10000;
                        this.createPhotonicBlast(powerUp.x, powerUp.y, 2);
                        break;
                    case 'dimension':
                        this.createPortalPair();
                        this.portalsActive = Date.now() + 8000;
                        break;
                    case 'neural':
                        this.aiAssist = Date.now() + 20000;
                        break;
                    case 'singularity':
                        this.createSingularity(powerUp.x, powerUp.y);
                        break;
                }
                
                this.updatePowerUpDisplay();
            }

            updatePowerUpDisplay() {
                let html = '';
                const now = Date.now();
                
                Object.entries(this.paddle.powerUps).forEach(([type, endTime]) => {
                    if (endTime > now) {
                        const remaining = Math.ceil((endTime - now) / 1000);
                        html += `<div class="powerup-item">${type.toUpperCase()}: ${remaining}s</div>`;
                    }
                });
                
                Object.entries(this.ball.powerUps).forEach(([type, endTime]) => {
                    if (endTime > now) {
                        const remaining = Math.ceil((endTime - now) / 1000);
                        html += `<div class="powerup-item">${type.toUpperCase()}: ${remaining}s</div>`;
                    }
                });
                
                this.powerupDisplay.innerHTML = html;
            }
            
            createLightningStorm() {
                for (let i = 0; i < 20; i++) {
                    setTimeout(() => {
                        const x = Math.random() * this.canvas.width;
                        const y = Math.random() * this.canvas.height * 0.6;
                        this.createLightningBolt(x, y, x + (Math.random() - 0.5) * 200, y + Math.random() * 300);
                        this.createParticles(x, y, '#b8860b', 5, 'energy');
                    }, i * 400);
                }
            }
            
            createLightningBolt(x1, y1, x2, y2) {
                this.lightning.push({
                    points: this.generateLightningPath(x1, y1, x2, y2),
                    life: 1,
                    decay: 0.1,
                    intensity: Math.random() * 0.5 + 0.5
                });
            }
            
            generateLightningPath(x1, y1, x2, y2) {
                const points = [{x: x1, y: y1}];
                const segments = 8;
                const displacement = 30;
                
                for (let i = 1; i <= segments; i++) {
                    const t = i / segments;
                    const x = x1 + (x2 - x1) * t + (Math.random() - 0.5) * displacement;
                    const y = y1 + (y2 - y1) * t + (Math.random() - 0.5) * displacement;
                    points.push({x, y});
                }
                
                return points;
            }
            
            createBlackHole(x, y) {
                this.wormholes.push({
                    x: x,
                    y: y,
                    radius: 0,
                    maxRadius: 80,
                    life: 1,
                    decay: 0.01,
                    gravitationalPull: 150,
                    eventHorizon: 30
                });
            }
            
            createPortalPair() {
                const portal1 = {
                    x: Math.random() * (this.canvas.width - 100) + 50,
                    y: Math.random() * (this.canvas.height * 0.3) + 100,
                    radius: 25,
                    color: '#ff69b4',
                    partner: 1
                };
                
                const portal2 = {
                    x: Math.random() * (this.canvas.width - 100) + 50,
                    y: Math.random() * (this.canvas.height * 0.3) + 300,
                    radius: 25,
                    color: '#00ffff',
                    partner: 0
                };
                
                this.portals = [portal1, portal2];
            }
            
            createSingularity(x, y) {
                this.quantumRifts.push({
                    x: x,
                    y: y,
                    radius: 5,
                    maxRadius: 120,
                    life: 1,
                    decay: 0.02,
                    distortionField: 200,
                    timeDialation: 0.1
                });
                
                // Create reality distortion effect
                for (let angle = 0; angle < Math.PI * 2; angle += 0.2) {
                    this.dimensionalFragments.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * 3,
                        vy: Math.sin(angle) * 3,
                        size: Math.random() * 8 + 2,
                        life: 1,
                        decay: 0.015,
                        color: `hsl(${Math.random() * 360}, 80%, 70%)`
                    });
                }
            }

            addScreenShake(intensity, duration) {
                this.screenShake.intensity = Math.max(this.screenShake.intensity, intensity);
                this.screenShake.duration = Math.max(this.screenShake.duration, duration);
            }

            updateScreenShake() {
                if (this.screenShake.duration > 0) {
                    this.screenShake.x = (Math.random() - 0.5) * this.screenShake.intensity;
                    this.screenShake.y = (Math.random() - 0.5) * this.screenShake.intensity;
                    this.screenShake.duration -= 16;
                    this.screenShake.intensity *= 0.95;
                } else {
                    this.screenShake.x = 0;
                    this.screenShake.y = 0;
                    this.screenShake.intensity = 0;
                }
            }

            hitBrick(brick, ball = this.ball) {
                brick.hits--;
                this.sounds.hit();
                
                if (brick.hits <= 0) {
                    brick.visible = false;
                    
                    this.combo++;
                    if (this.combo > this.maxCombo) this.maxCombo = this.combo;
                    
                    const baseScore = brick.points * this.multiplier;
                    const comboBonus = Math.floor(this.combo / 5) * baseScore;
                    this.score += baseScore + comboBonus;
                    
                    this.multiplier = 1 + Math.floor(this.combo / 10);
                    this.ultimateCharge = Math.min(100, this.ultimateCharge + 5);
                    
                    // Track achievement stats
                    if (this.playerStats) {
                        this.playerStats.bricksDestroyed++;
                    }
                    
                    this.createParticles(brick.x + brick.width/2, brick.y + brick.height/2, brick.color, 8);
                    this.handleSpecialBrick(brick);
                    this.addScreenShake(3, 150);
                    
                    if (Math.random() < 0.02 * this.level) {
                        this.spawnEnemy(brick.x + brick.width/2, brick.y + brick.height/2);
                    }
                } else {
                    brick.glowIntensity = 1;
                    this.createParticles(brick.x + brick.width/2, brick.y + brick.height/2, brick.color, 3);
                }
                
                const speedIncrease = 1.01;
                ball.speedX *= speedIncrease;
                ball.speedY *= speedIncrease;
            }

            handleSpecialBrick(brick) {
                switch (brick.type) {
                    case 'explosive':
                        this.explodeBricks(brick.x + brick.width/2, brick.y + brick.height/2, 80);
                        this.addScreenShake(12, 500);
                        break;
                    case 'powerup':
                        this.spawnPowerUp(brick.x, brick.y);
                        break;
                    case 'treasure':
                        this.score += brick.points * 5;
                        this.createParticles(brick.x + brick.width/2, brick.y + brick.height/2, '#ffd700', 20, 'treasure');
                        break;
                }
            }

            explodeBricks(centerX, centerY, radius) {
                this.bricks.forEach(brick => {
                    if (brick.visible) {
                        const distance = Math.sqrt(
                            Math.pow(brick.x + brick.width/2 - centerX, 2) + 
                            Math.pow(brick.y + brick.height/2 - centerY, 2)
                        );
                        if (distance < radius) {
                            this.hitBrick(brick);
                        }
                    }
                });
            }

            updateSpecialEffects() {
                this.bricks.forEach(brick => {
                    if (brick.glowIntensity > 0) {
                        brick.glowIntensity -= 0.05;
                    }
                });
                
                const now = Date.now();
                Object.keys(this.paddle.powerUps).forEach(key => {
                    if (this.paddle.powerUps[key] < now) {
                        if (key === 'wide' && this.paddle.powerUps[key] > 0) {
                            this.paddle.width /= 1.5;
                        }
                        this.paddle.powerUps[key] = 0;
                    }
                });
                
                Object.keys(this.ball.powerUps).forEach(key => {
                    if (this.ball.powerUps[key] < now) {
                        this.ball.powerUps[key] = 0;
                    }
                });
                
                this.updatePowerUpDisplay();
            }

            render() {
                // Solid dark background
                this.ctx.fillStyle = '#000022';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
                this.ctx.lineWidth = 1;
                const gridSize = 50;
                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                for (let y = 0; y < this.canvas.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }

                // Draw Western-themed bricks
                for (let brick of this.bricks) {
                    if (!brick.visible) continue;
                    
                    this.ctx.save();
                    
                    // Draw as wooden crates/barrels with Western themes
                    switch (brick.type) {
                        case 'armored': // Metal safe
                            // Draw metallic safe
                            const safeGradient = this.ctx.createLinearGradient(brick.x, brick.y, brick.x, brick.y + brick.height);
                            safeGradient.addColorStop(0, '#696969');
                            safeGradient.addColorStop(0.5, '#808080');
                            safeGradient.addColorStop(1, '#4a4a4a');
                            this.ctx.fillStyle = safeGradient;
                            this.ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                            
                            // Add metal rivets
                            this.ctx.fillStyle = '#3a3a3a';
                            this.ctx.beginPath();
                            this.ctx.arc(brick.x + 5, brick.y + 5, 2, 0, Math.PI * 2);
                            this.ctx.arc(brick.x + brick.width - 5, brick.y + 5, 2, 0, Math.PI * 2);
                            this.ctx.arc(brick.x + 5, brick.y + brick.height - 5, 2, 0, Math.PI * 2);
                            this.ctx.arc(brick.x + brick.width - 5, brick.y + brick.height - 5, 2, 0, Math.PI * 2);
                            this.ctx.fill();
                            break;
                            
                        case 'explosive': // TNT crate
                            // Red TNT box
                            this.ctx.fillStyle = '#8b0000';
                            this.ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                            this.ctx.fillStyle = '#dc143c';
                            this.ctx.fillRect(brick.x + 2, brick.y + 2, brick.width - 4, brick.height - 4);
                            
                            // TNT label
                            this.ctx.fillStyle = '#ffff00';
                            this.ctx.font = 'bold 10px Rye';
                            this.ctx.textAlign = 'center';
                            this.ctx.fillText('TNT', brick.x + brick.width/2, brick.y + brick.height/2 + 4);
                            break;
                            
                        case 'treasure': // Gold bar
                            // Shiny gold gradient
                            const goldGradient = this.ctx.createLinearGradient(brick.x, brick.y, brick.x + brick.width, brick.y + brick.height);
                            goldGradient.addColorStop(0, '#ffd700');
                            goldGradient.addColorStop(0.3, '#ffed4e');
                            goldGradient.addColorStop(0.6, '#ffd700');
                            goldGradient.addColorStop(1, '#b8860b');
                            this.ctx.fillStyle = goldGradient;
                            this.ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                            
                            // Gold shine effect
                            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                            this.ctx.fillRect(brick.x + brick.width/3, brick.y + 2, brick.width/4, brick.height - 4);
                            break;
                            
                        case 'powerup': // Whiskey barrel
                            // Barrel gradient
                            const barrelGradient = this.ctx.createLinearGradient(brick.x, brick.y, brick.x, brick.y + brick.height);
                            barrelGradient.addColorStop(0, '#654321');
                            barrelGradient.addColorStop(0.5, '#8b4513');
                            barrelGradient.addColorStop(1, '#654321');
                            this.ctx.fillStyle = barrelGradient;
                            this.ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                            
                            // Barrel bands
                            this.ctx.fillStyle = '#3a3a3a';
                            this.ctx.fillRect(brick.x, brick.y + 3, brick.width, 2);
                            this.ctx.fillRect(brick.x, brick.y + brick.height - 5, brick.width, 2);
                            break;
                            
                        default: // Wooden crate
                            // Wood grain effect
                            const woodGradient = this.ctx.createLinearGradient(brick.x, brick.y, brick.x + brick.width, brick.y);
                            const baseColor = brick.color;
                            woodGradient.addColorStop(0, baseColor);
                            woodGradient.addColorStop(0.2, this.lightenColor(baseColor));
                            woodGradient.addColorStop(0.5, baseColor);
                            woodGradient.addColorStop(0.8, this.darkenColor(baseColor));
                            woodGradient.addColorStop(1, baseColor);
                            this.ctx.fillStyle = woodGradient;
                            this.ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                            
                            // Wood grain lines
                            this.ctx.strokeStyle = this.darkenColor(baseColor);
                            this.ctx.lineWidth = 0.5;
                            this.ctx.beginPath();
                            this.ctx.moveTo(brick.x, brick.y + brick.height/3);
                            this.ctx.lineTo(brick.x + brick.width, brick.y + brick.height/3);
                            this.ctx.moveTo(brick.x, brick.y + 2*brick.height/3);
                            this.ctx.lineTo(brick.x + brick.width, brick.y + 2*brick.height/3);
                            this.ctx.stroke();
                    }
                    
                    // Add wooden frame border for all bricks
                    this.ctx.strokeStyle = '#3e2723';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);
                    
                    if (brick.glowIntensity > 0) {
                        this.ctx.shadowColor = brick.color;
                        this.ctx.shadowBlur = 20 * brick.glowIntensity;
                        this.ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                        this.ctx.shadowBlur = 0;
                    }
                    
                    if (brick.type === 'armored' && brick.hits < brick.maxHits) {
                        const healthWidth = (brick.width - 4) * (brick.hits / brick.maxHits);
                        this.ctx.fillStyle = '#ff0000';
                        this.ctx.fillRect(brick.x + 2, brick.y + 2, healthWidth, 3);
                    }
                    
                    if (brick.type === 'treasure') {
                        const pulse = Math.sin(Date.now() * 0.01) * 0.5 + 0.5;
                        this.ctx.shadowColor = '#ffff00';
                        this.ctx.shadowBlur = 10 + pulse * 10;
                        this.ctx.strokeStyle = '#ffff00';
                        this.ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);
                        this.ctx.shadowBlur = 0;
                    }
                }

                // Draw paddle as sheriff's badge
                this.ctx.save();
                
                // Main badge shape with brass gradient
                const badgeGradient = this.ctx.createLinearGradient(
                    this.paddle.x, this.paddle.y, 
                    this.paddle.x, this.paddle.y + this.paddle.height
                );
                badgeGradient.addColorStop(0, '#daa520');
                badgeGradient.addColorStop(0.3, '#ffd700');
                badgeGradient.addColorStop(0.7, '#b8860b');
                badgeGradient.addColorStop(1, '#8b6914');
                
                this.ctx.fillStyle = badgeGradient;
                this.ctx.fillRect(this.paddle.x, this.paddle.y, this.paddle.width, this.paddle.height);
                
                // Badge star in center
                const centerX = this.paddle.x + this.paddle.width / 2;
                const centerY = this.paddle.y + this.paddle.height / 2;
                
                this.ctx.fillStyle = '#8b4513';
                this.ctx.font = 'bold 10px Rye';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText('SHERIFF', centerX, centerY);
                
                // Metal border
                this.ctx.strokeStyle = '#654321';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(this.paddle.x, this.paddle.y, this.paddle.width, this.paddle.height);
                
                // Shine effect
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                this.ctx.fillRect(this.paddle.x + 2, this.paddle.y + 2, this.paddle.width - 4, 2);
                
                this.ctx.restore();
                
                // Add effects for power-ups
                if (this.paddle.powerUps.laser > Date.now()) {
                    this.ctx.strokeStyle = '#ff0000';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(this.paddle.x - 2, this.paddle.y - 2, this.paddle.width + 4, this.paddle.height + 4);
                }
                
                if (this.paddle.powerUps.wide > Date.now()) {
                    this.ctx.strokeStyle = '#00ff00';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(this.paddle.x - 1, this.paddle.y - 1, this.paddle.width + 2, this.paddle.height + 2);
                }
                
                if (this.paddle.powerUps.shield > Date.now()) {
                    this.ctx.strokeStyle = '#00ffff';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.strokeRect(this.paddle.x - 4, this.paddle.y - 4, this.paddle.width + 8, this.paddle.height + 8);
                    this.ctx.setLineDash([]);
                }

                // Draw power-ups
                for (let powerUp of this.powerUps) {
                    const pulse = Math.sin(powerUp.pulse) * 0.3 + 0.7;
                    this.ctx.fillStyle = powerUp.color;
                    this.ctx.shadowColor = powerUp.color;
                    this.ctx.shadowBlur = 10 * pulse;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(powerUp.x + powerUp.width/2, powerUp.y + powerUp.height/2, powerUp.width/2, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = '12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(powerUp.type[0].toUpperCase(), powerUp.x + powerUp.width/2, powerUp.y + powerUp.height/2 + 4);
                    
                    this.ctx.shadowBlur = 0;
                }
                
                // Draw particles
                // Draw trails first
                for (let trail of this.trails) {
                    const alpha = trail.life;
                    this.ctx.globalAlpha = alpha;
                    this.ctx.fillStyle = trail.color;
                    this.ctx.beginPath();
                    this.ctx.arc(trail.x, trail.y, trail.size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                // Draw photonic blasts
                for (let blast of this.photonicBlasts) {
                    this.ctx.save();
                    const alpha = blast.life * 0.7;
                    this.ctx.globalAlpha = alpha;
                    
                    for (let i = 0; i < blast.rings; i++) {
                        const ringRadius = blast.radius * (i + 1) / blast.rings;
                        const ringAlpha = alpha * (1 - i / blast.rings);
                        this.ctx.globalAlpha = ringAlpha;
                        
                        const gradient = this.ctx.createRadialGradient(
                            blast.x, blast.y, ringRadius * 0.8,
                            blast.x, blast.y, ringRadius
                        );
                        gradient.addColorStop(0, `rgba(0, 255, 255, ${ringAlpha})`);
                        gradient.addColorStop(1, `rgba(138, 43, 226, 0)`);
                        
                        this.ctx.strokeStyle = gradient;
                        this.ctx.lineWidth = 3;
                        this.ctx.beginPath();
                        this.ctx.arc(blast.x, blast.y, ringRadius, 0, Math.PI * 2);
                        this.ctx.stroke();
                    }
                    this.ctx.restore();
                }
                
                // Draw enhanced particles
                for (let particle of this.particles) {
                    const alpha = particle.opacity !== undefined ? particle.opacity * particle.life : particle.life;
                    this.ctx.globalAlpha = alpha;
                    
                    this.ctx.save();
                    
                    if (particle.glow) {
                        this.ctx.shadowColor = particle.color;
                        this.ctx.shadowBlur = particle.size * 2;
                    }
                    
                    if (particle.rotation !== undefined) {
                        this.ctx.translate(particle.x, particle.y);
                        this.ctx.rotate(particle.rotation);
                    }
                    
                    if (particle.type === 'treasure') {
                        this.ctx.fillStyle = particle.color;
                        this.ctx.fillRect(-particle.size/2, -particle.size/2, particle.size, particle.size);
                    } else if (particle.type === 'quantum') {
                        // Quantum particles have shifting colors and phase effects
                        const hue = (Date.now() * 0.1 + particle.phase * 57.3) % 360;
                        this.ctx.fillStyle = `hsla(${hue}, 100%, 70%, ${alpha})`;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.rotation !== undefined ? 0 : particle.x, 
                                   particle.rotation !== undefined ? 0 : particle.y, 
                                   particle.size * (1 + Math.sin(particle.phase) * 0.3), 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        // Add quantum shimmer effect
                        this.ctx.globalAlpha = alpha * 0.5;
                        this.ctx.strokeStyle = `hsla(${(hue + 180) % 360}, 100%, 90%, ${alpha})`;
                        this.ctx.lineWidth = 1;
                        this.ctx.stroke();
                    } else if (particle.type === 'energy') {
                        // Energy particles with wave effects
                        const gradient = this.ctx.createRadialGradient(
                            particle.rotation !== undefined ? 0 : particle.x, 
                            particle.rotation !== undefined ? 0 : particle.y, 0,
                            particle.rotation !== undefined ? 0 : particle.x, 
                            particle.rotation !== undefined ? 0 : particle.y, particle.size * 2
                        );
                        gradient.addColorStop(0, particle.color);
                        gradient.addColorStop(1, 'transparent');
                        this.ctx.fillStyle = gradient;
                        
                        this.ctx.beginPath();
                        this.ctx.arc(particle.rotation !== undefined ? 0 : particle.x, 
                                   particle.rotation !== undefined ? 0 : particle.y, 
                                   particle.size, 0, Math.PI * 2);
                        this.ctx.fill();
                    } else if (particle.type === 'spiral') {
                        // Spiral particles with trailing effect
                        this.ctx.strokeStyle = particle.color;
                        this.ctx.lineWidth = particle.size;
                        this.ctx.lineCap = 'round';
                        this.ctx.beginPath();
                        this.ctx.moveTo(particle.rotation !== undefined ? -particle.size : particle.x - particle.size, 
                                      particle.rotation !== undefined ? 0 : particle.y);
                        this.ctx.lineTo(particle.rotation !== undefined ? particle.size : particle.x + particle.size, 
                                      particle.rotation !== undefined ? 0 : particle.y);
                        this.ctx.stroke();
                    } else {
                        // Standard particles
                        this.ctx.fillStyle = particle.color;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.rotation !== undefined ? 0 : particle.x, 
                                   particle.rotation !== undefined ? 0 : particle.y, 
                                   particle.size, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    this.ctx.restore();
                }
                this.ctx.globalAlpha = 1;

                // Draw all balls as Western bullets/cannonballs
                for (let ball of this.balls) {
                    this.ctx.save();
                    
                    // Create bullet/cannonball gradient
                    const gradient = this.ctx.createRadialGradient(
                        ball.x - ball.radius * 0.3, ball.y - ball.radius * 0.3, 0,
                        ball.x, ball.y, ball.radius
                    );
                    gradient.addColorStop(0, '#c0c0c0'); // Silver highlight
                    gradient.addColorStop(0.4, '#808080'); // Dark silver
                    gradient.addColorStop(0.8, '#404040'); // Dark metal
                    gradient.addColorStop(1, '#202020'); // Black outline
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Add metallic rim for bullet effect
                    this.ctx.strokeStyle = '#2f1b14';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                    
                    // Pierce effect - glowing bullet
                    if (ball.powerUps.pierce > Date.now()) {
                        this.ctx.strokeStyle = '#ffd700';
                        this.ctx.lineWidth = 3;
                        this.ctx.stroke();
                        this.ctx.shadowBlur = 10;
                        this.ctx.shadowColor = '#ffd700';
                    }
                    
                    const speed = Math.sqrt(ball.speedX ** 2 + ball.speedY ** 2);
                    if (speed > 2) {
                        this.ctx.globalAlpha = 0.4;
                        for (let i = 1; i <= 3; i++) {
                            this.ctx.beginPath();
                            this.ctx.arc(
                                ball.x - ball.speedX * i * 2,
                                ball.y - ball.speedY * i * 2,
                                ball.radius * (1 - i * 0.2),
                                0, Math.PI * 2
                            );
                            // Trail looks like gunpowder smoke
                            const trailGradient = this.ctx.createRadialGradient(
                                ball.x - ball.speedX * i * 2, ball.y - ball.speedY * i * 2, 0,
                                ball.x - ball.speedX * i * 2, ball.y - ball.speedY * i * 2, ball.radius * (1 - i * 0.2)
                            );
                            trailGradient.addColorStop(0, '#a0a0a0');
                            trailGradient.addColorStop(1, '#404040');
                            this.ctx.fillStyle = trailGradient;
                            this.ctx.fill();
                        }
                    }
                    
                    this.ctx.restore();
                }
                
                // Draw enemies
                for (let enemy of this.enemies) {
                    this.ctx.save();
                    this.ctx.translate(enemy.x, enemy.y);
                    this.ctx.rotate(enemy.angle);
                    
                    const pulse = Math.sin(enemy.pulse) * 0.2 + 1;
                    
                    this.ctx.shadowColor = enemy.color;
                    this.ctx.shadowBlur = 15 * pulse;
                    
                    const enemyGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, enemy.radius);
                    enemyGradient.addColorStop(0, enemy.color);
                    enemyGradient.addColorStop(0.7, this.darkenColor(enemy.color));
                    enemyGradient.addColorStop(1, '#000000');
                    
                    this.ctx.fillStyle = enemyGradient;
                    this.ctx.beginPath();
                    
                    if (enemy.type === 'seeker') {
                        for (let i = 0; i < 6; i++) {
                            const angle = (Math.PI * 2 / 6) * i;
                            const x = Math.cos(angle) * enemy.radius * pulse;
                            const y = Math.sin(angle) * enemy.radius * pulse;
                            if (i === 0) this.ctx.moveTo(x, y);
                            else this.ctx.lineTo(x, y);
                        }
                    } else {
                        this.ctx.arc(0, 0, enemy.radius * pulse, 0, Math.PI * 2);
                    }
                    
                    this.ctx.fill();
                    this.ctx.restore();
                }
                
                // Draw boss
                if (this.boss && this.boss.active) {
                    this.ctx.save();
                    
                    const bossGradient = this.ctx.createLinearGradient(
                        this.boss.x, this.boss.y, 
                        this.boss.x, this.boss.y + this.boss.height
                    );
                    bossGradient.addColorStop(0, '#ff00ff');
                    bossGradient.addColorStop(0.5, '#8800ff');
                    bossGradient.addColorStop(1, '#440088');
                    
                    this.ctx.fillStyle = bossGradient;
                    this.ctx.shadowColor = '#ff00ff';
                    this.ctx.shadowBlur = 30 + Math.sin(Date.now() * 0.01) * 10;
                    
                    this.ctx.fillRect(this.boss.x, this.boss.y, this.boss.width, this.boss.height);
                    
                    // Boss health bar
                    const healthPercent = this.boss.health / this.boss.maxHealth;
                    this.ctx.fillStyle = '#000000';
                    this.ctx.fillRect(this.boss.x, this.boss.y - 20, this.boss.width, 10);
                    
                    const healthGradient = this.ctx.createLinearGradient(
                        this.boss.x, this.boss.y - 20,
                        this.boss.x + this.boss.width * healthPercent, this.boss.y - 20
                    );
                    healthGradient.addColorStop(0, '#ff0000');
                    healthGradient.addColorStop(1, '#ffff00');
                    
                    this.ctx.fillStyle = healthGradient;
                    this.ctx.fillRect(this.boss.x, this.boss.y - 20, this.boss.width * healthPercent, 10);
                    
                    // Boss eyes
                    this.ctx.fillStyle = '#ff0000';
                    this.ctx.shadowColor = '#ff0000';
                    this.ctx.shadowBlur = 20;
                    this.ctx.beginPath();
                    this.ctx.arc(this.boss.x + this.boss.width * 0.3, this.boss.y + this.boss.height * 0.3, 10, 0, Math.PI * 2);
                    this.ctx.arc(this.boss.x + this.boss.width * 0.7, this.boss.y + this.boss.height * 0.3, 10, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
                
                // Draw obstacles
                for (let obstacle of this.obstacles) {
                    this.ctx.save();
                    
                    const obstacleGradient = this.ctx.createLinearGradient(
                        obstacle.x, obstacle.y,
                        obstacle.x, obstacle.y + obstacle.height
                    );
                    obstacleGradient.addColorStop(0, obstacle.color);
                    obstacleGradient.addColorStop(1, this.darkenColor(obstacle.color));
                    
                    this.ctx.fillStyle = obstacleGradient;
                    this.ctx.shadowColor = obstacle.color;
                    this.ctx.shadowBlur = obstacle.type === 'gravity' ? 30 : 10;
                    
                    this.ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                    
                    if (obstacle.type === 'gravity') {
                        this.ctx.strokeStyle = obstacle.color;
                        this.ctx.lineWidth = 2;
                        this.ctx.setLineDash([5, 5]);
                        this.ctx.beginPath();
                        this.ctx.arc(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2, 150, 0, Math.PI * 2);
                        this.ctx.stroke();
                        this.ctx.setLineDash([]);
                    }
                    
                    this.ctx.restore();
                }
                
                // Draw explosions
                for (let exp of this.explosions) {
                    this.ctx.save();
                    this.ctx.globalAlpha = exp.life;
                    
                    const expGradient = this.ctx.createRadialGradient(
                        exp.x, exp.y, 0,
                        exp.x, exp.y, exp.radius
                    );
                    expGradient.addColorStop(0, '#ffffff');
                    expGradient.addColorStop(0.3, '#ffff00');
                    expGradient.addColorStop(0.6, '#ff8800');
                    expGradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    
                    this.ctx.fillStyle = expGradient;
                    this.ctx.beginPath();
                    this.ctx.arc(exp.x, exp.y, exp.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.restore();
                }
                
                // Draw shockwaves
                for (let wave of this.shockwaves) {
                    this.ctx.save();
                    this.ctx.globalAlpha = wave.life * 0.5;
                    this.ctx.strokeStyle = wave.color;
                    this.ctx.lineWidth = 3;
                    this.ctx.shadowColor = wave.color;
                    this.ctx.shadowBlur = 20;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);
                    this.ctx.stroke();
                    
                    this.ctx.restore();
                }
                
                // Draw lasers
                for (let laser of this.lasers) {
                    this.ctx.save();
                    
                    if (laser.type === 'boss') {
                        this.ctx.translate(laser.x, laser.y);
                        this.ctx.rotate(laser.angle);
                        
                        const laserGradient = this.ctx.createLinearGradient(0, 0, laser.width, 0);
                        laserGradient.addColorStop(0, 'rgba(255, 0, 255, 0)');
                        laserGradient.addColorStop(0.5, laser.color);
                        laserGradient.addColorStop(1, 'rgba(255, 0, 255, 0)');
                        
                        this.ctx.fillStyle = laserGradient;
                        this.ctx.shadowColor = laser.glow;
                        this.ctx.shadowBlur = 30;
                        this.ctx.fillRect(0, -laser.width/2, laser.height, laser.width);
                        
                        laser.life--;
                    } else {
                        this.ctx.fillStyle = laser.color;
                        this.ctx.shadowColor = laser.glow;
                        this.ctx.shadowBlur = 15;
                        this.ctx.fillRect(laser.x, laser.y, laser.width, laser.height);
                    }
                    
                    this.ctx.restore();
                }
                
                // Draw ultimate charge bar
                if (this.ultimateCharge > 0) {
                    const barWidth = 200;
                    const barHeight = 20;
                    const barX = this.canvas.width / 2 - barWidth / 2;
                    const barY = this.canvas.height - 60;
                    
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    this.ctx.fillRect(barX, barY, barWidth, barHeight);
                    
                    const chargeGradient = this.ctx.createLinearGradient(barX, barY, barX + barWidth * (this.ultimateCharge / 100), barY);
                    chargeGradient.addColorStop(0, '#ff0000');
                    chargeGradient.addColorStop(0.5, '#ffff00');
                    chargeGradient.addColorStop(1, '#00ff00');
                    
                    this.ctx.fillStyle = chargeGradient;
                    this.ctx.fillRect(barX, barY, barWidth * (this.ultimateCharge / 100), barHeight);
                    
                    if (this.ultimateCharge >= 100) {
                        this.ctx.strokeStyle = '#00ff00';
                        this.ctx.lineWidth = 3;
                        this.ctx.shadowColor = '#00ff00';
                        this.ctx.shadowBlur = 20 + Math.sin(Date.now() * 0.01) * 10;
                        this.ctx.strokeRect(barX - 2, barY - 2, barWidth + 4, barHeight + 4);
                        
                        this.ctx.fillStyle = '#00ff00';
                        this.ctx.font = 'bold 14px Courier New';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText('ULTIMATE READY! Press SPACE', this.canvas.width / 2, barY - 10);
                    }
                }

                if (this.gameState === 'paused') {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    this.ctx.fillStyle = '#ffff00';
                    this.ctx.shadowColor = '#ffff00';
                    this.ctx.shadowBlur = 20;
                    this.ctx.font = '48px Courier New';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('⏸️ PAUSED', this.canvas.width / 2, this.canvas.height / 2);
                    
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.shadowBlur = 10;
                    this.ctx.font = '24px Courier New';
                    this.ctx.fillText('⚡ Press SPACE to resume', this.canvas.width / 2, this.canvas.height / 2 + 60);
                    this.ctx.shadowBlur = 0;
                }

                this.updateUI();
            }

            darkenColor(color) {
                const colors = {
                    '#ff0000': '#cc0000',
                    '#ff4400': '#cc2200',
                    '#ff8800': '#cc4400',
                    '#ffcc00': '#cc9900',
                    '#88ff00': '#66cc00',
                    '#00ff00': '#00cc00',
                    '#00ffcc': '#00cc99',
                    '#0088ff': '#0066cc',
                    '#ff00ff': '#cc00cc',
                    '#00ffff': '#00cccc',
                    '#ffff00': '#cccc00',
                    '#880088': '#660066',
                    '#008888': '#006666',
                    '#ff88ff': '#cc66cc',
                    '#8800ff': '#6600cc',
                    '#ffffff': '#cccccc'
                };
                return colors[color] || '#666666';
            }

            lightenColor(color) {
                const colors = {
                    '#ff0000': '#ff4444',
                    '#ff4400': '#ff6644',
                    '#ff8800': '#ffaa44',
                    '#ffcc00': '#ffdd44',
                    '#88ff00': '#aeff44',
                    '#00ff00': '#44ff44',
                    '#00ffcc': '#44ffdd',
                    '#0088ff': '#44aaff',
                    '#ff00ff': '#ff44ff',
                    '#00ffff': '#44ffff',
                    '#ffff00': '#ffff44',
                    '#880088': '#aa44aa',
                    '#008888': '#44aaaa',
                    '#ff88ff': '#ffaaff',
                    '#8800ff': '#aa44ff',
                    '#ffffff': '#ffffff'
                };
                return colors[color] || '#aaaaaa';
            }

            updateUI() {
                this.scoreElement.textContent = this.score.toLocaleString();
                this.livesElement.textContent = this.lives;
                this.levelElement.textContent = `LEVEL ${this.level}`;
                this.multiplierElement.textContent = `x${this.multiplier}`;
                this.comboElement.textContent = this.combo;
                
                if (this.combo > 5) {
                    this.comboDisplay.classList.add('active');
                } else {
                    this.comboDisplay.classList.remove('active');
                }
            }

            activateBulletTime() {
                if (!this.bulletTime) {
                    this.bulletTime = true;
                    this.timeScale = 0.3;
                    this.addScreenShake(5, 1000);
                    
                    // Create lightning effect
                    for (let i = 0; i < 20; i++) {
                        this.lightning.push({
                            x: Math.random() * this.canvas.width,
                            y: Math.random() * this.canvas.height,
                            life: 1,
                            decay: 0.05
                        });
                    }
                    
                    setTimeout(() => {
                        this.bulletTime = false;
                        this.timeScale = 1.0;
                    }, 3000);
                }
            }
            
            fireLaser() {
                if (this.paddle.powerUps.laser > Date.now()) {
                    for (let i = 0; i < 3; i++) {
                        this.lasers.push({
                            x: this.paddle.x + (this.paddle.width / 4) * (i + 1),
                            y: this.paddle.y,
                            width: 4,
                            height: 20,
                            speed: -15,
                            color: '#ff0000',
                            glow: '#ff6666'
                        });
                    }
                    this.addScreenShake(3, 200);
                }
            }
            
            updateLasers() {
                for (let i = this.lasers.length - 1; i >= 0; i--) {
                    const laser = this.lasers[i];
                    laser.y += laser.speed * this.timeScale;
                    
                    // Check laser-brick collision
                    for (let brick of this.bricks) {
                        if (brick.visible && 
                            laser.x < brick.x + brick.width &&
                            laser.x + laser.width > brick.x &&
                            laser.y < brick.y + brick.height &&
                            laser.y + laser.height > brick.y) {
                            
                            this.hitBrick(brick);
                            this.createParticles(laser.x, laser.y, '#ff0000', 5);
                            this.lasers.splice(i, 1);
                            break;
                        }
                    }
                    
                    if (laser.y < 0) {
                        this.lasers.splice(i, 1);
                    }
                }
            }
            
            updateLightning() {
                for (let i = this.lightning.length - 1; i >= 0; i--) {
                    const bolt = this.lightning[i];
                    bolt.life -= bolt.decay;
                    
                    if (bolt.life <= 0) {
                        this.lightning.splice(i, 1);
                    }
                }
            }
            
            updateAdvancedEffects() {
                const now = Date.now();
                
                // Update wormholes/black holes
                for (let i = this.wormholes.length - 1; i >= 0; i--) {
                    const hole = this.wormholes[i];
                    hole.radius = hole.maxRadius * (1 - hole.life);
                    hole.life -= hole.decay;
                    
                    // Apply gravitational pull to balls
                    for (let ball of this.balls) {
                        const dx = hole.x - ball.x;
                        const dy = hole.y - ball.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < hole.gravitationalPull) {
                            const force = (hole.gravitationalPull - dist) / hole.gravitationalPull;
                            ball.speedX += (dx / dist) * force * 0.5;
                            ball.speedY += (dy / dist) * force * 0.5;
                        }
                    }
                    
                    if (hole.life <= 0) {
                        this.wormholes.splice(i, 1);
                    }
                }
                
                // Update quantum rifts
                for (let i = this.quantumRifts.length - 1; i >= 0; i--) {
                    const rift = this.quantumRifts[i];
                    rift.radius = rift.maxRadius * (1 - rift.life);
                    rift.life -= rift.decay;
                    
                    if (rift.life <= 0) {
                        this.quantumRifts.splice(i, 1);
                    }
                }
                
                // Update dimensional fragments
                for (let i = this.dimensionalFragments.length - 1; i >= 0; i--) {
                    const fragment = this.dimensionalFragments[i];
                    fragment.x += fragment.vx;
                    fragment.y += fragment.vy;
                    fragment.life -= fragment.decay;
                    
                    if (fragment.life <= 0) {
                        this.dimensionalFragments.splice(i, 1);
                    }
                }
            }
            
            updateTimeEffects() {
                const now = Date.now();
                
                // Handle bullet time
                if (this.bulletTime && now > this.bulletTimeEnd) {
                    this.bulletTime = false;
                    this.timeScale = 1.0;
                }
                
                // Apply time scale to all movements
                if (this.timeScale !== 1.0) {
                    for (let ball of this.balls) {
                        ball.speedX *= this.timeScale;
                        ball.speedY *= this.timeScale;
                    }
                }
            }
            
            updatePortals() {
                if (!this.portals || Date.now() > this.portalsActive) {
                    this.portals = null;
                    return;
                }
                
                // Check for ball portal collisions
                for (let ball of this.balls) {
                    for (let i = 0; i < this.portals.length; i++) {
                        const portal = this.portals[i];
                        const dx = ball.x - portal.x;
                        const dy = ball.y - portal.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < portal.radius) {
                            const partner = this.portals[portal.partner];
                            ball.x = partner.x;
                            ball.y = partner.y;
                            this.createParticles(partner.x, partner.y, partner.color, 10, 'energy');
                            break;
                        }
                    }
                }
            }
            
            setupAudio() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.audioContext.createGain();
                this.masterGain.connect(this.audioContext.destination);
                this.masterGain.gain.value = 0.7;
                
                this.musicGain = this.audioContext.createGain();
                this.musicGain.connect(this.masterGain);
                this.musicGain.gain.value = 0.3;
                
                this.sfxGain = this.audioContext.createGain();
                this.sfxGain.connect(this.masterGain);
                this.sfxGain.gain.value = 0.8;
                
                this.sounds = {
                    hit: () => this.playRicochetSound(),
                    explosion: () => this.playDynamiteSound(),
                    powerup: () => this.playSpurSound(),
                    laser: () => this.playGunshotSound(),
                    boss: () => this.playTumbleweedSound(),
                    ultimate: () => this.playHighNoonSound(),
                    enemy: () => this.playHorseNeighSound(),
                    quantum: () => this.playGhostSound(),
                    wormhole: () => this.playWindSound(),
                    portal: () => this.playMineCartSound()
                };
                
                this.startBackgroundMusic();
                this.setupDynamicAudio();
            }
            
            playAdvancedSound(frequency, duration, type = 'sine', envelope = [1, 0.3, 0], effects = {}) {
                if (this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                const filterNode = this.audioContext.createBiquadFilter();
                
                oscillator.connect(filterNode);
                filterNode.connect(gainNode);
                gainNode.connect(this.sfxGain);
                
                oscillator.frequency.value = frequency;
                oscillator.type = type;
                
                if (effects.filter) {
                    filterNode.type = effects.filter.type || 'lowpass';
                    filterNode.frequency.value = effects.filter.frequency || 2000;
                    filterNode.Q.value = effects.filter.resonance || 1;
                }
                
                const [attack, sustain, release] = envelope;
                const now = this.audioContext.currentTime;
                
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(attack * 0.3, now + duration * 0.1);
                gainNode.gain.setValueAtTime(sustain * 0.3, now + duration * 0.7);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                if (effects.frequencySweep) {
                    oscillator.frequency.linearRampToValueAtTime(
                        effects.frequencySweep,
                        now + duration
                    );
                }
                
                oscillator.start(now);
                oscillator.stop(now + duration);
            }
            
            playRicochetSound() {
                // Bullet hitting metal sound
                this.playAdvancedSound(
                    800 + Math.random() * 400,
                    0.15,
                    'triangle',
                    [1, 0.2, 0],
                    { frequencySweep: 200, filter: { type: 'bandpass', frequency: 1200 } }
                );
            }
            
            playDynamiteSound() {
                // Big boom explosion
                for (let i = 0; i < 4; i++) {
                    setTimeout(() => {
                        this.playAdvancedSound(
                            Math.random() * 150 + 40,
                            0.5 - i * 0.08,
                            'sawtooth',
                            [1, 0.3, 0],
                            { frequencySweep: 30, filter: { type: 'lowpass', frequency: 200 } }
                        );
                    }, i * 40);
                }
            }
            
            playSpurSound() {
                // Jingly spur sound
                const frequencies = [800, 1000, 1200, 1400];
                frequencies.forEach((freq, i) => {
                    setTimeout(() => {
                        this.playAdvancedSound(freq, 0.15, 'triangle', [1, 0.6, 0]);
                    }, i * 40);
                });
            }
            
            playGunshotSound() {
                // Sharp gunshot crack
                this.playAdvancedSound(
                    150,
                    0.12,
                    'sawtooth',
                    [1, 0.1, 0],
                    { frequencySweep: 80, filter: { type: 'highpass', frequency: 100 } }
                );
                // Add echo
                setTimeout(() => {
                    this.playAdvancedSound(120, 0.08, 'sawtooth', [0.3, 0.05, 0]);
                }, 150);
            }
            
            playTumbleweedSound() {
                // Low ominous wind sound
                this.playAdvancedSound(
                    45,
                    1.0,
                    'sine',
                    [0.6, 0.8, 0.2],
                    { filter: { type: 'lowpass', frequency: 120 } }
                );
            }
            
            playHighNoonSound() {
                // Dramatic western showdown chord
                const chordFreqs = [110, 146.83, 220, 293.66]; // Western minor chord
                chordFreqs.forEach((freq, i) => {
                    setTimeout(() => {
                        this.playAdvancedSound(
                            freq,
                            0.8,
                            'triangle',
                            [0.8, 0.9, 0.3]
                        );
                    }, i * 50);
                });
            }
            
            playHorseNeighSound() {
                // Horse neigh approximation
                this.playAdvancedSound(
                    400,
                    0.4,
                    'sawtooth',
                    [0.8, 0.4, 0],
                    { frequencySweep: 800, filter: { type: 'bandpass', frequency: 600 } }
                );
            }
            
            playGhostSound() {
                // Spooky ghost whistle
                for (let i = 0; i < 6; i++) {
                    setTimeout(() => {
                        this.playAdvancedSound(
                            Math.random() * 300 + 400,
                            0.2,
                            'sine',
                            [0.6, 0.8, 0.2]
                        );
                    }, i * 40);
                }
            }
            
            playWindSound() {
                // Desert wind howl
                this.playAdvancedSound(
                    60,
                    1.8,
                    'sine',
                    [0.4, 0.7, 0.3],
                    { 
                        frequencySweep: 120,
                        filter: { type: 'lowpass', frequency: 180 }
                    }
                );
            }
            
            playMineCartSound() {
                // Mine cart rolling on tracks
                const frequencies = [200, 150, 180];
                frequencies.forEach((freq, i) => {
                    setTimeout(() => {
                        this.playAdvancedSound(
                            freq,
                            0.6,
                            'square',
                            [0.7, 0.5, 0.2],
                            { filter: { type: 'bandpass', frequency: freq * 1.5 } }
                        );
                    }, i * 150);
                });
            }
            
            startBackgroundMusic() {
                if (this.backgroundMusic) return;
                
                this.backgroundMusic = true;
                this.musicSequence = [
                    { note: 110, duration: 0.5 },
                    { note: 146.83, duration: 0.5 },
                    { note: 174.61, duration: 0.5 },
                    { note: 220, duration: 0.5 },
                    { note: 293.66, duration: 1.0 },
                    { note: 220, duration: 0.5 },
                    { note: 174.61, duration: 0.5 },
                    { note: 146.83, duration: 1.0 }
                ];
                this.musicIndex = 0;
                this.playNextNote();
            }
            
            playNextNote() {
                if (!this.backgroundMusic || this.gameState !== 'playing') {
                    setTimeout(() => this.playNextNote(), 1000);
                    return;
                }
                
                const note = this.musicSequence[this.musicIndex];
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                const filterNode = this.audioContext.createBiquadFilter();
                
                oscillator.connect(filterNode);
                filterNode.connect(gainNode);
                gainNode.connect(this.musicGain);
                
                oscillator.frequency.value = note.note;
                oscillator.type = 'triangle';
                
                filterNode.type = 'lowpass';
                filterNode.frequency.value = note.note * 4;
                
                const now = this.audioContext.currentTime;
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(0.1, now + 0.05);
                gainNode.gain.linearRampToValueAtTime(0.05, now + note.duration * 0.8);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + note.duration);
                
                oscillator.start(now);
                oscillator.stop(now + note.duration);
                
                this.musicIndex = (this.musicIndex + 1) % this.musicSequence.length;
                setTimeout(() => this.playNextNote(), note.duration * 1000);
            }
            
            setupDynamicAudio() {
                this.lastIntensityUpdate = 0;
                this.gameIntensity = 0;
            }
            
            updateAudioIntensity() {
                if (Date.now() - this.lastIntensityUpdate < 100) return;
                
                this.lastIntensityUpdate = Date.now();
                const targetIntensity = Math.min(1, (
                    this.level * 0.1 +
                    this.enemies.length * 0.05 +
                    (this.boss ? 0.3 : 0) +
                    this.combo * 0.02
                ));
                
                this.gameIntensity += (targetIntensity - this.gameIntensity) * 0.1;
                
                if (this.musicGain) {
                    this.musicGain.gain.value = 0.2 + this.gameIntensity * 0.2;
                }
            }
            
            splitBalls() {
                const newBalls = [];
                for (let ball of this.balls) {
                    if (this.balls.length >= 8) break;
                    
                    for (let i = 0; i < 2; i++) {
                        const angle = (Math.PI * 2 / 3) * (i + 1);
                        const newBall = {
                            x: ball.x,
                            y: ball.y,
                            radius: ball.radius,
                            speedX: Math.cos(angle) * Math.abs(ball.speedX),
                            speedY: Math.sin(angle) * Math.abs(ball.speedY),
                            color: ['#ff00ff', '#00ffff', '#ffff00'][Math.floor(Math.random() * 3)],
                            trail: [],
                            powerUps: {...ball.powerUps}
                        };
                        newBalls.push(newBall);
                    }
                }
                this.balls.push(...newBalls);
                this.sounds.powerup();
                this.createShockwave(this.paddle.x + this.paddle.width/2, this.paddle.y);
            }
            
            spawnEnemy(x, y) {
                const types = ['seeker', 'bomber', 'shield', 'splitter'];
                const type = types[Math.floor(Math.random() * types.length)];
                
                this.enemies.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 2,
                    vy: Math.random() * 2 + 1,
                    radius: 15,
                    type: type,
                    health: 2 + Math.floor(this.level / 3),
                    color: type === 'seeker' ? '#ff0000' : type === 'bomber' ? '#ff8800' : type === 'shield' ? '#0088ff' : '#ff00ff',
                    angle: 0,
                    pulse: 0
                });
            }
            
            updateEnemies() {
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    
                    enemy.pulse += 0.1;
                    enemy.angle += 0.05;
                    
                    if (enemy.type === 'seeker') {
                        const dx = this.paddle.x + this.paddle.width/2 - enemy.x;
                        enemy.vx += Math.sign(dx) * 0.1;
                        enemy.vx = Math.max(-3, Math.min(3, enemy.vx));
                    }
                    
                    enemy.x += enemy.vx;
                    enemy.y += enemy.vy;
                    
                    if (enemy.x <= enemy.radius || enemy.x >= this.canvas.width - enemy.radius) {
                        enemy.vx = -enemy.vx;
                    }
                    
                    if (enemy.y > this.canvas.height - 100) {
                        if (enemy.type === 'bomber') {
                            this.createExplosion(enemy.x, enemy.y, 100);
                            this.addScreenShake(20, 500);
                        }
                        this.enemies.splice(i, 1);
                    }
                    
                    if (Math.abs(enemy.x - (this.paddle.x + this.paddle.width/2)) < this.paddle.width/2 + enemy.radius &&
                        Math.abs(enemy.y - this.paddle.y) < enemy.radius + this.paddle.height) {
                        if (!this.paddle.powerUps.shield || this.paddle.powerUps.shield < Date.now()) {
                            this.lives--;
                            this.addScreenShake(25, 800);
                        }
                        this.destroyEnemy(enemy);
                    }
                }
            }
            
            destroyEnemy(enemy) {
                const index = this.enemies.indexOf(enemy);
                if (index > -1) {
                    this.enemies.splice(index, 1);
                    this.score += 500 * this.multiplier;
                    this.ultimateCharge = Math.min(100, this.ultimateCharge + 15);
                    this.createExplosion(enemy.x, enemy.y, 50);
                    this.sounds.enemy();
                    
                    if (enemy.type === 'splitter') {
                        for (let i = 0; i < 3; i++) {
                            const angle = (Math.PI * 2 / 3) * i;
                            this.enemies.push({
                                x: enemy.x,
                                y: enemy.y,
                                vx: Math.cos(angle) * 2,
                                vy: Math.sin(angle) * 2,
                                radius: 8,
                                type: 'mini',
                                health: 1,
                                color: '#ff88ff',
                                angle: 0,
                                pulse: 0
                            });
                        }
                    }
                }
            }
            
            updateBoss() {
                if (!this.boss || !this.boss.active) return;
                
                this.boss.phase = Math.floor((this.boss.maxHealth - this.boss.health) / (this.boss.maxHealth / 3)) + 1;
                
                this.boss.x = this.canvas.width/2 + Math.sin(Date.now() * 0.001) * 200;
                this.boss.angle += 0.02;
                
                if (Math.random() < 0.02 * this.boss.phase) {
                    this.bossAttack();
                }
                
                if (this.boss.health <= 0) {
                    this.defeatBoss();
                }
            }
            
            bossAttack() {
                const attacks = ['laser', 'missiles', 'shockwave', 'summon'];
                const attack = attacks[Math.floor(Math.random() * attacks.length)];
                
                switch(attack) {
                    case 'laser':
                        for (let i = 0; i < 5; i++) {
                            setTimeout(() => {
                                this.createBossLaser(this.boss.x + this.boss.width/2, this.boss.y + this.boss.height);
                            }, i * 100);
                        }
                        break;
                    case 'missiles':
                        for (let i = 0; i < 3; i++) {
                            this.enemies.push({
                                x: this.boss.x + Math.random() * this.boss.width,
                                y: this.boss.y + this.boss.height,
                                vx: (Math.random() - 0.5) * 3,
                                vy: 3,
                                radius: 10,
                                type: 'missile',
                                health: 1,
                                color: '#ff0000',
                                angle: 0,
                                pulse: 0
                            });
                        }
                        break;
                    case 'shockwave':
                        this.createShockwave(this.boss.x + this.boss.width/2, this.boss.y + this.boss.height/2);
                        this.addScreenShake(30, 1000);
                        break;
                    case 'summon':
                        for (let i = 0; i < 2; i++) {
                            this.spawnEnemy(this.boss.x + Math.random() * this.boss.width, this.boss.y);
                        }
                        break;
                }
                this.sounds.boss();
            }
            
            createBossLaser(x, y) {
                const targetX = this.paddle.x + this.paddle.width/2;
                const angle = Math.atan2(this.paddle.y - y, targetX - x);
                
                this.lasers.push({
                    x: x,
                    y: y,
                    width: 8,
                    height: this.canvas.height,
                    speed: 0,
                    color: '#a0522d',
                    glow: '#ff88ff',
                    angle: angle,
                    life: 30,
                    type: 'boss'
                });
                
                this.addScreenShake(10, 300);
            }
            
            hitBoss() {
                if (!this.boss || !this.boss.active) return;
                
                this.boss.health--;
                this.score += 1000 * this.multiplier;
                this.createExplosion(this.boss.x + Math.random() * this.boss.width, 
                                   this.boss.y + Math.random() * this.boss.height, 30);
                this.sounds.boss();
                
                if (this.boss.health <= 0) {
                    this.defeatBoss();
                }
            }
            
            defeatBoss() {
                this.boss.active = false;
                this.score += 10000 * this.level * this.multiplier;
                
                for (let i = 0; i < 20; i++) {
                    setTimeout(() => {
                        this.createExplosion(
                            this.boss.x + Math.random() * this.boss.width,
                            this.boss.y + Math.random() * this.boss.height,
                            50 + Math.random() * 50
                        );
                    }, i * 100);
                }
                
                this.addScreenShake(50, 2000);
                this.createShockwave(this.boss.x + this.boss.width/2, this.boss.y + this.boss.height/2);
                
                setTimeout(() => {
                    this.boss = null;
                    this.levelComplete();
                }, 2500);
            }
            
            createExplosion(x, y, radius) {
                this.explosions.push({
                    x: x,
                    y: y,
                    radius: 0,
                    maxRadius: radius,
                    life: 1,
                    color: '#ff8800'
                });
                
                for (let i = 0; i < radius/5; i++) {
                    this.createParticles(x, y, ['#ff0000', '#ff8800', '#ffff00'][Math.floor(Math.random() * 3)], 3, 'explosion');
                }
                
                this.sounds.explosion();
            }
            
            createShockwave(x, y) {
                this.shockwaves.push({
                    x: x,
                    y: y,
                    radius: 0,
                    maxRadius: 300,
                    life: 1,
                    color: '#00ffff'
                });
            }
            
            updateObstacles() {
                if (this.level > 3 && Math.random() < 0.001 * this.level) {
                    this.obstacles.push({
                        x: Math.random() * this.canvas.width,
                        y: -50,
                        width: 50 + Math.random() * 100,
                        height: 20,
                        vy: 1 + Math.random() * 2,
                        type: Math.random() > 0.5 ? 'barrier' : 'gravity',
                        color: Math.random() > 0.5 ? '#880088' : '#008888'
                    });
                }
                
                for (let i = this.obstacles.length - 1; i >= 0; i--) {
                    const obstacle = this.obstacles[i];
                    obstacle.y += obstacle.vy;
                    
                    if (obstacle.type === 'gravity') {
                        for (let ball of this.balls) {
                            const dx = obstacle.x + obstacle.width/2 - ball.x;
                            const dy = obstacle.y + obstacle.height/2 - ball.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            
                            if (dist < 150) {
                                const force = (150 - dist) / 150 * 0.2;
                                ball.speedX += dx / dist * force;
                                ball.speedY += dy / dist * force;
                            }
                        }
                    }
                    
                    if (obstacle.y > this.canvas.height) {
                        this.obstacles.splice(i, 1);
                    }
                }
            }
            
            updateUltimate() {
                // Ultimate is now activated through handleSpaceKey
                // This method can be used for other ultimate-related updates
            }
            
            activateUltimate() {
                this.ultimateCharge = 0;
                this.sounds.ultimate();
                
                this.createShockwave(this.paddle.x + this.paddle.width/2, this.paddle.y);
                
                for (let i = 0; i < 10; i++) {
                    const angle = (Math.PI * 2 / 10) * i;
                    const ball = {
                        x: this.paddle.x + this.paddle.width/2,
                        y: this.paddle.y,
                        radius: 8,
                        speedX: Math.cos(angle) * 5,
                        speedY: Math.sin(angle) * 5,
                        color: '#ffd700',
                        trail: [],
                        powerUps: { pierce: Date.now() + 5000 }
                    };
                    this.balls.push(ball);
                }
                
                this.addScreenShake(40, 1500);
                this.bulletTime = true;
                this.timeScale = 0.3;
                
                setTimeout(() => {
                    this.bulletTime = false;
                    this.timeScale = 1.0;
                }, 3000);
            }
            
            updateExplosions() {
                for (let i = this.explosions.length - 1; i >= 0; i--) {
                    const exp = this.explosions[i];
                    exp.radius += (exp.maxRadius - exp.radius) * 0.3;
                    exp.life -= 0.05;
                    
                    if (exp.life <= 0) {
                        this.explosions.splice(i, 1);
                    }
                }
            }
            
            updateShockwaves() {
                for (let i = this.shockwaves.length - 1; i >= 0; i--) {
                    const wave = this.shockwaves[i];
                    wave.radius += 10;
                    wave.life -= 0.03;
                    
                    if (wave.life <= 0 || wave.radius > wave.maxRadius) {
                        this.shockwaves.splice(i, 1);
                    }
                }
            }
            
            gameLoop() {
                // Performance monitoring
                if (this.performanceMetrics) {
                    this.updatePerformanceMetrics();
                }
                
                this.ctx.save();
                this.ctx.translate(this.screenShake.x, this.screenShake.y);
                
                this.update();
                this.updateExplosions();
                this.updateShockwaves();
                this.render();
                
                this.ctx.restore();
                requestAnimationFrame(() => this.gameLoop());
            }
            
            // Performance and Analytics Methods (Simplified)
            updatePerformanceMetrics() {
                // Basic performance tracking
                const now = performance.now();
                if (this.lastFrameTime) {
                    const fps = 1000 / (now - this.lastFrameTime);
                    if (fps < 30) {
                        // Reduce particle count if performance is poor
                        if (this.particles.length > 100) {
                            this.particles.splice(0, 50);
                        }
                        if (this.trails.length > 50) {
                            this.trails.splice(0, 25);
                        }
                    }
                }
                this.lastFrameTime = now;
            }
            
            initializePerformanceMonitoring() {
                this.performanceMetrics = { enabled: true };
                this.lastFrameTime = 0;
            }
            
            loadHighScores() {
                const saved = localStorage.getItem('cyberBreakoutHighScores');
                this.highScores = saved ? JSON.parse(saved) : [];
            }
            
            saveHighScore(playerName, score) {
                const newScore = {
                    name: playerName || 'ANONYMOUS',
                    score: score,
                    date: new Date().toLocaleDateString()
                };
                
                this.highScores.push(newScore);
                this.highScores.sort((a, b) => b.score - a.score);
                this.highScores = this.highScores.slice(0, 10); // Keep only top 10
                
                localStorage.setItem('cyberBreakoutHighScores', JSON.stringify(this.highScores));
                return this.isNewHighScore(score);
            }
            
            isNewHighScore(score) {
                return this.highScores.length < 10 || score > this.highScores[this.highScores.length - 1].score;
            }
            
            getPlayerName() {
                return this.playerNameInput.value.trim().toUpperCase() || 'PLAYER';
            }
            
            showHighScores() {
                this.gameState = 'highScores';
                this.startScreen.classList.add('hidden');
                this.gameOverScreen.classList.add('hidden');
                this.highScoresScreen.classList.remove('hidden');
                this.updateHighScoresDisplay();
            }
            
            hideHighScores() {
                this.highScoresScreen.classList.add('hidden');
                this.gameState = 'start';
                this.startScreen.classList.remove('hidden');
            }
            
            updateHighScoresDisplay() {
                if (this.highScores.length === 0) {
                    this.highScoresList.innerHTML = '<p style="color: #666; text-align: center; padding: 40px;">No high scores yet!</p>';
                    return;
                }
                
                let html = '<div style="display: flex; flex-direction: column; gap: 10px;">';
                this.highScores.forEach((score, index) => {
                    const rank = index + 1;
                    const medal = rank === 1 ? '🥇' : rank === 2 ? '🥈' : rank === 3 ? '🥉' : `${rank}.`;
                    html += `
                        <div style="display: flex; justify-content: space-between; align-items: center; 
                                    background: rgba(0, 255, 255, 0.1); padding: 15px; border-radius: 10px; 
                                    border: 1px solid rgba(0, 255, 255, 0.3);">
                            <span style="color: #00ffff; font-weight: bold; min-width: 40px;">${medal}</span>
                            <span style="color: #fff; flex-grow: 1; text-align: left; margin-left: 15px;">${score.name}</span>
                            <span style="color: #ffff00; font-weight: bold; min-width: 80px; text-align: right;">${score.score.toLocaleString()}</span>
                            <span style="color: #888; font-size: 12px; min-width: 80px; text-align: right;">${score.date}</span>
                        </div>
                    `;
                });
                html += '</div>';
                this.highScoresList.innerHTML = html;
            }
        }

        // Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('data:application/javascript;base64,Y29uc3Qgc3cgPSBzZWxmOw0Kc3cuYWRkRXZlbnRMaXN0ZW5lcignZmV0Y2gnLCBldmVudCA9PiB7DQogICAgZXZlbnQucmVzcG9uZFdpdGgoZmV0Y2goZXZlbnQucmVxdWVzdCkpOw0KfSk7')
                    .then(registration => console.log('SW registered'))
                    .catch(error => console.log('SW registration failed'));
            });
        }
        
        // Install prompt handling
        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            
            // Show install button after 10 seconds of gameplay
            setTimeout(() => {
                if (deferredPrompt && document.getElementById('installBtn')) {
                    document.getElementById('installBtn').style.display = 'block';
                }
            }, 10000);
        });
        
        function installApp() {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        console.log('User accepted the install prompt');
                    }
                    deferredPrompt = null;
                });
            }
        }
        
        window.addEventListener('load', () => {
            window.game = new SuperBreakout();
        });
    </script>
</body>
</html>